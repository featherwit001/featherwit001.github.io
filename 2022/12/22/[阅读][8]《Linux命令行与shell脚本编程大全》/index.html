<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="缘起​	室友在某次项目中海量的机械重复操作，使我意识到使用脚本自动化处理能够节省多少的时间。这本书一看就很厚实，但是参考机械重复操作耗费的时间，这点前期投入不值一提。 ​	在这里记录一些自己不太熟悉的内容，当做备忘录查询">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux命令行与shell脚本编程大全">
<meta property="og:url" content="http://example.com/2022/12/22/[%E9%98%85%E8%AF%BB][8]%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%85%A8%E3%80%8B/index.html">
<meta property="og:site_name" content="学海注">
<meta property="og:description" content="缘起​	室友在某次项目中海量的机械重复操作，使我意识到使用脚本自动化处理能够节省多少的时间。这本书一看就很厚实，但是参考机械重复操作耗费的时间，这点前期投入不值一提。 ​	在这里记录一些自己不太熟悉的内容，当做备忘录查询">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2022/12/22/%5B%E9%98%85%E8%AF%BB%5D%5B8%5D%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%85%A8%E3%80%8B/s29584559.jpg">
<meta property="og:image" content="http://example.com/2022/12/22/%5B%E9%98%85%E8%AF%BB%5D%5B8%5D%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%85%A8%E3%80%8B/image-20221222211243363.png">
<meta property="og:image" content="http://example.com/2022/12/22/%5B%E9%98%85%E8%AF%BB%5D%5B8%5D%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%85%A8%E3%80%8B/image-20221222224248450.png">
<meta property="og:image" content="http://example.com/2022/12/22/%5B%E9%98%85%E8%AF%BB%5D%5B8%5D%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%85%A8%E3%80%8B/image-20221222230009221.png">
<meta property="og:image" content="http://example.com/2022/12/22/%5B%E9%98%85%E8%AF%BB%5D%5B8%5D%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%85%A8%E3%80%8B/image-20221223141859380.png">
<meta property="og:image" content="http://example.com/2022/12/22/%5B%E9%98%85%E8%AF%BB%5D%5B8%5D%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%85%A8%E3%80%8B/image-20221223143341085.png">
<meta property="og:image" content="http://example.com/2022/12/22/%5B%E9%98%85%E8%AF%BB%5D%5B8%5D%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%85%A8%E3%80%8B/image-20221223150543794.png">
<meta property="og:image" content="http://example.com/2022/12/22/%5B%E9%98%85%E8%AF%BB%5D%5B8%5D%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%85%A8%E3%80%8B/image-20221223215409327.png">
<meta property="og:image" content="http://example.com/2022/12/22/%5B%E9%98%85%E8%AF%BB%5D%5B8%5D%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%85%A8%E3%80%8B/image-20221223222203304.png">
<meta property="og:image" content="http://example.com/2022/12/22/%5B%E9%98%85%E8%AF%BB%5D%5B8%5D%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%85%A8%E3%80%8B/image-20221224160901450.png">
<meta property="og:image" content="http://example.com/2022/12/22/%5B%E9%98%85%E8%AF%BB%5D%5B8%5D%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%85%A8%E3%80%8B/image-20221224161653901.png">
<meta property="og:image" content="http://example.com/2022/12/22/%5B%E9%98%85%E8%AF%BB%5D%5B8%5D%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%85%A8%E3%80%8B/image-20221224163611079.png">
<meta property="og:image" content="http://example.com/2022/12/22/%5B%E9%98%85%E8%AF%BB%5D%5B8%5D%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%85%A8%E3%80%8B/image-20221224204654127.png">
<meta property="og:image" content="http://example.com/2022/12/22/%5B%E9%98%85%E8%AF%BB%5D%5B8%5D%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%85%A8%E3%80%8B/image-20221227161845392.png">
<meta property="og:image" content="http://example.com/2022/12/22/%5B%E9%98%85%E8%AF%BB%5D%5B8%5D%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%85%A8%E3%80%8B/image-20221227161755238.png">
<meta property="og:image" content="http://example.com/2022/12/22/%5B%E9%98%85%E8%AF%BB%5D%5B8%5D%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%85%A8%E3%80%8B/image-20221227152446122.png">
<meta property="article:published_time" content="2022-12-22T03:05:32.000Z">
<meta property="article:modified_time" content="2022-12-27T08:20:58.427Z">
<meta property="article:author" content="fea01">
<meta property="article:tag" content="学习记录">
<meta property="article:tag" content="shell">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/12/22/%5B%E9%98%85%E8%AF%BB%5D%5B8%5D%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%85%A8%E3%80%8B/s29584559.jpg">

<link rel="canonical" href="http://example.com/2022/12/22/[%E9%98%85%E8%AF%BB][8]%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%85%A8%E3%80%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Linux命令行与shell脚本编程大全 | 学海注</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">学海注</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/22/[%E9%98%85%E8%AF%BB][8]%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%85%A8%E3%80%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="fea01">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学海注">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Linux命令行与shell脚本编程大全
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-22 11:05:32" itemprop="dateCreated datePublished" datetime="2022-12-22T11:05:32+08:00">2022-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-27 16:20:58" itemprop="dateModified" datetime="2022-12-27T16:20:58+08:00">2022-12-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/books/" itemprop="url" rel="index"><span itemprop="name">books</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>​	室友在某次项目中海量的机械重复操作，使我意识到使用脚本自动化处理能够节省多少的时间。这本书一看就很厚实，但是参考机械重复操作耗费的时间，这点前期投入不值一提。</p>
<p>​	在这里记录一些自己不太熟悉的内容，当做备忘录查询</p>
<p><img src="/2022/12/22/%5B%E9%98%85%E8%AF%BB%5D%5B8%5D%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%85%A8%E3%80%8B/s29584559.jpg"></p>
<span id="more"></span>



<h1 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h1><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p>​	Ubuntu 使用的是GNOME Terminal 仿真器，几个能够提高效率的快捷键。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>快捷键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>启动终端</td>
<td>Ctrl + Alt + T</td>
<td>Ubuntu Unity 桌面环境中  快速访问GNOME终端</td>
</tr>
<tr>
<td>Open Terminal</td>
<td>Shift+Ctrl+N</td>
<td>在新的GNOME Terminal窗口中启动一个新的shell会话</td>
</tr>
<tr>
<td>Open Tab</td>
<td>Shift+Ctrl+T</td>
<td>在现有的GNOME Terminal窗口的新标签中启动一个新的shell会话</td>
</tr>
<tr>
<td>Close Tab</td>
<td>Shift+Ctrl+W</td>
<td>关闭当前标签中的会话</td>
</tr>
<tr>
<td>Close Window</td>
<td>Shift+Ctrl+Q</td>
<td>关闭当前的GNOME Terminal会话</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>名称</th>
<th>快捷键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Copy</td>
<td>Shift+Ctrl+C</td>
<td>将所选的文本复制到GNOME的剪贴板中</td>
</tr>
<tr>
<td>Paste</td>
<td>Shift+Ctrl+V</td>
<td>将GNOME剪贴板中的文本粘贴到会话中</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>名称</th>
<th>快捷键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Zoom In</td>
<td>Ctrl++</td>
<td>逐步增大窗口显示字号</td>
</tr>
<tr>
<td>Zoom Out</td>
<td>Ctrl+-</td>
<td>逐步减小窗口显示字号</td>
</tr>
<tr>
<td>Normal Size</td>
<td>Ctrl+0</td>
<td>恢复默认字号</td>
</tr>
</tbody></table>
<p>​	</p>
<h2 id="第三章-基本bash-shell-命令"><a href="#第三章-基本bash-shell-命令" class="headerlink" title="第三章 基本bash shell 命令"></a>第三章 基本bash shell 命令</h2><p>​		Linux会在根驱动器上创建一些特别的目录，我们称之为挂载点（mount point）。</p>
<p>​		挂载点是虚拟目录中用于分配额外存储设备的目录。虚拟目录会让文件和目录出现在这些挂载点目录中，然而实际上它们却存储在另外一个驱动器中。</p>
<p>ls -l（long 长列表） -F (斜杠区分目录) -R (递归显示)</p>
<p>可以加模式匹配</p>
<p>​		ls -l my_scr?pt</p>
<p>​		ls -l my_s*t</p>
<p>防止文件被覆盖，最好加-i ，交互在覆盖前确认</p>
<p>mv -i</p>
<p>cp -i</p>
<p>链接文件</p>
<p>ln -s <src> <dst></p>
<p>ln <src> <dst></p>
<p>rmdir 只能删除空目录</p>
<p>rm -r 递归删除 -f 强制删除不询问 -i 删除前确认</p>
<p>常用file确认文件类型</p>
<p>less is more，less 命令查看文件内容，翻页</p>
<p>tail &#x2F;head -5 或者 -n 5</p>
<p>cat -n （显示行号，包括空行） -b (显示行号，不算空行)</p>
<h2 id="第四章-更多bash-shell-监控和处理"><a href="#第四章-更多bash-shell-监控和处理" class="headerlink" title="第四章 更多bash shell 监控和处理"></a>第四章 更多bash shell 监控和处理</h2><p>Linux系统中使用的GNU ps 命令支持3种不同类型的命令行参数：<br>    Unix风格的参数，前面加单破折线；<br>    BSD风格的参数，前面不加破折线；<br>    GNU风格的长参数，前面加双破折线。</p>
<h3 id="ps-命令"><a href="#ps-命令" class="headerlink" title="ps 命令"></a>ps 命令</h3><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-f</td>
<td>显示完整格式的输出</td>
</tr>
<tr>
<td>-e</td>
<td>显示所有进程</td>
</tr>
<tr>
<td>-l</td>
<td>长格式输出，比 -f 多出</td>
</tr>
<tr>
<td>l</td>
<td>BSD风格，进程状态更清晰</td>
</tr>
<tr>
<td>–forest</td>
<td>用层级结构显示出进程和父进程之间的关系</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="top-命令"><a href="#top-命令" class="headerlink" title="top 命令"></a>top 命令</h3><p>键入f允许你选择对输出进行排序的字段，</p>
<p>键入d允许你修改轮询间隔。</p>
<p>键入q可以退出 top 。</p>
<h3 id="kill-命令"><a href="#kill-命令" class="headerlink" title="kill 命令"></a>kill 命令</h3><p>kill pid</p>
<p>kill -s HUP pid （-s 选择其他信号）</p>
<p>killall 进程名（可用通配符）</p>
<p>​	killall http*</p>
<h3 id="mount-命令"><a href="#mount-命令" class="headerlink" title="mount 命令"></a>mount 命令</h3><p>mount 命令提供如下四部分信息：<br> 媒体的设备文件名<br> 媒体挂载到虚拟目录的挂载点<br> 文件系统类型<br> 已挂载媒体的访问状态</p>
<p>手动挂载</p>
<p>mount -t type device directory</p>
<p>手动将U盘&#x2F;dev&#x2F;sdb1挂载到&#x2F;media&#x2F;disk，可用下面的命令：<br>mount -t vfat &#x2F;dev&#x2F;sdb1 &#x2F;media&#x2F;disk</p>
<p>卸载设备</p>
<p>umount [directory | device ]</p>
<p>如果有任何程序正在使用设备上的文件，系统就不会允许你卸载它：</p>
<p>可用lsof命令获得使用它的进程信息，然后在应用中停止使用该设备或停止该进程。lsof命令的用法很简<br>单：lsof &#x2F;path&#x2F;to&#x2F;device&#x2F;node，或者lsof &#x2F;path&#x2F;to&#x2F;mount&#x2F;point</p>
<h3 id="df-du-和-dd命令"><a href="#df-du-和-dd命令" class="headerlink" title="df du 和 dd命令"></a>df du 和 dd命令</h3><p>disk free </p>
<p>df -h <file path></p>
<p>disk usage</p>
<p>du -h</p>
<h3 id="sort-数据排序"><a href="#sort-数据排序" class="headerlink" title="sort 数据排序"></a>sort 数据排序</h3><p>sort -n 识别数字 -M 用三字符月份名按月份排序</p>
<p>-t 分割符号， -k 列数 规定排序字段</p>
<p>sort -t ‘:’ -k 3 -n &#x2F;etc&#x2F;passwd</p>
<h3 id="grep-搜索数据"><a href="#grep-搜索数据" class="headerlink" title="grep 搜索数据"></a>grep 搜索数据</h3><p>grep [options] pattern [file]</p>
<p>如果要进行反向搜索（输出不匹配该模式的行），可加 -v 参数。</p>
<p>如果要显示匹配模式的行所在的行号，可加 -n 参数。</p>
<p>如果只要知道有多少行含有匹配的模式，可用 -c 参数。</p>
<p>如果要指定多个匹配模式，可用 -e 参数来指定每个模式。</p>
<p>grep -e t -e f file1</p>
<p>使用正则表达式</p>
<p>grep [tf] file1</p>
<h3 id="tar-归档数据"><a href="#tar-归档数据" class="headerlink" title="tar 归档数据"></a>tar 归档数据</h3><p> tar -zxvf filename.tgz 解压</p>
<p>tar  -zcvf  [newfilename.tar.gz]  [objectlist….] 压缩</p>
<p>tar -cvf  不压缩</p>
<h2 id="第五章-理解shell"><a href="#第五章-理解shell" class="headerlink" title="第五章 理解shell"></a>第五章 理解shell</h2><p>bash 参数</p>
<table>
<thead>
<tr>
<th>参 数</th>
<th>描 述</th>
</tr>
</thead>
<tbody><tr>
<td>-i</td>
<td>启动一个能够接收用户输入的交互shell</td>
</tr>
<tr>
<td>-l</td>
<td>以登录shell的形式启动</td>
</tr>
<tr>
<td>-r</td>
<td>启动一个受限shell，用户会被限制在默认目录中</td>
</tr>
</tbody></table>
<p>(command;….) 创建进程列表，生成子shell执行命令</p>
<p>echo $BASH_SUBSHELL  结果为0表示不存在子shell执行命令，为1 则是子shell执行</p>
<p>&amp; 后台执行</p>
<p><strong>jobs</strong> -l 查看后台作业</p>
<p>协程，但看起来不常用</p>
<p><strong>corproc</strong> name { command; }</p>
<p>当外部命令执行时，会创建出一个子进程。</p>
<p>就算衍生出子进程或是创建了子shell，你仍然可以通过发送信号与其沟通，这一点无论是<br>在命令行还是在脚本编写中都是极其有用的。发送信号（signaling）使得进程间可以通过<br>信号进行通信。</p>
<p>内建命令和外部命令的区别在于前者不需要使用子进程来执行。它们已经和shell编译成了一<br>体，作为shell工具的组成部分存在。</p>
<p>可以利用 <strong>type 命令</strong>来了解某个命令是否是内建的</p>
<p>type -a 查看多种实现</p>
<p>有些命令有多种实现。例如 echo 和 pwd 既有内建命令也有外部命令。</p>
<h3 id="history"><a href="#history" class="headerlink" title="history"></a>history</h3><p>显示最近执行过的命令</p>
<p>!! 最新命令</p>
<p>当输入 !! 时，bash首先会显示出从shell的历史记录中唤回的命令。然后执行该命令。<br>命令历史记录被保存在隐藏文件.bash_history中。</p>
<p>bash命令的历史记录是先存放在内存中，当shell退出时才被写入到历史文件中。</p>
<p>要实现强制写入，需要使用 history 命令的 -a选 项。</p>
<p>要想强制重新读取.bash_history文件，更新终端会话的历史记录，可以使用 history -n 命令。</p>
<p>!20 执行第20号命令</p>
<h3 id="alias-命令别名"><a href="#alias-命令别名" class="headerlink" title="alias 命令别名"></a>alias 命令别名</h3><p>alias -p 查看已经存在的命令别名</p>
<p>alias li&#x3D;’ls -li’</p>
<p>因为命令别名属于内部命令，一个别名仅在它所被定义的shell进程中才有效。</p>
<h2 id="第六章-环境变量"><a href="#第六章-环境变量" class="headerlink" title="第六章 环境变量"></a>第六章 环境变量</h2><p>env &#x2F; printenv 展示 全局环境变量</p>
<p> set 命令会显示为某个特定进程设置的所有环境变量，包括局部变量、全局变量<br>以及用户定义变量。</p>
<p><strong>创建局部环境变量</strong></p>
<p>my_variable&#x3D;”hello world”</p>
<p>变量名、等号和值之间没有空格</p>
<p><strong>创建全局环境变量</strong></p>
<p>先创建一个局部环境变量，然后再把它导出到全局环境中(export var_name)</p>
<p><strong>删除环境变量</strong></p>
<p>unset var_name</p>
<p>在 unset 命令中引用环境变量时，记住不要使用 $</p>
<p>如果要用到变量，使用 $ </p>
<p>如果要操作变量，不使用 $ 。</p>
<p>这条规则的一个例外就是使用 printenv 显示某个变量的值。</p>
<p>不是所有的默认环境变量都会在运行 set 命令时列出。尽管这些都是默<br>认环境变量，但并不是每一个都必须有一个值。</p>
<h3 id="PATH变量"><a href="#PATH变量" class="headerlink" title="PATH变量"></a>PATH变量</h3><p>PATH&#x3D;$PATH:&#x2F;home&#x2F;christine&#x2F;Scripts</p>
<p>#导出</p>
<p>export PATH&#x3D;$PATH:&#x2F;home&#x2F;christine&#x2F;Scripts </p>
<p>当你登录Linux系统时，bash shell会作为登录shell启动。登录shell会从5个不同的启动文件里<br>读取命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/etc/profile</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">HOME/.bash_profile</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">HOME/.bashrc</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">HOME/.bash_login</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">HOME/.profile</span></span><br></pre></td></tr></table></figure>

<p>shell会按照按照下列顺序，运行第一个被找到的文件，余下的则被忽略：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">HOME/.bash_profile</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">HOME/.bash_login</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">HOME/.profile</span></span><br></pre></td></tr></table></figure>

<p>注意，这个列表中并没有$HOME&#x2F;.bashrc文件。这是因为该文件通常通过其他文件运行的</p>
<p>如果bash是作为交互式shell启动的，它就不会访问&#x2F;etc&#x2F;profile文件，只会检查用户HOME目录中的.bashrc文件。</p>
<p>.bashrc文件有两个作用：一是查看&#x2F;etc目录下通用的bashrc文件，二是为用户提供一个定制自己的命令别名（参见第5章）和私有脚本函数（将在第17章中讲到）的地方。</p>
<p>最后一种shell是非交互式shell。系统执行shell脚本时用的就是这种shell。</p>
<p>bash shell提供了 BASH_ENV 环境变量。当shell启动一个非交互式shell进<br>程时，它会检查这个环境变量来查看要执行的启动文件。</p>
<h3 id="持久化环境变量"><a href="#持久化环境变量" class="headerlink" title="持久化环境变量"></a><strong>持久化环境变量</strong></h3><p>最好是在**&#x2F;etc&#x2F;profile.d目录中创建一个以.sh结尾的文件**。把所有新的或修改过的全局环境变<br>量设置放在这个文件中。</p>
<p>在大多数发行版中，存储个人用户永久性bash shell变量的地方是**$HOME&#x2F;.bashrc**文件。</p>
<p>但如果设置了 BASH_ENV 变量，那么记住，除非它指向的是<br>$HOME&#x2F;.bashrc，否则你应该将非交互式shell的用户变量放在别的地方。</p>
<p>图形化界面组成部分（如GUI客户端）的环境变量可能需要在另外一些配置文件中设置</p>
<h3 id="数组变量"><a href="#数组变量" class="headerlink" title="数组变量"></a>数组变量</h3><p>移植性不好，不常用</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mytest=(one two three four five)</span><br><span class="line">echo $mytest # 只会显示$mytest[0]</span><br><span class="line">echo $&#123;mytest[*]&#125;</span><br><span class="line"></span><br><span class="line">mytest[2]=seven # 修改</span><br><span class="line"></span><br><span class="line">unset mytest[2] # 删除，使得这个位置的变量为空</span><br></pre></td></tr></table></figure>





<h2 id="第七章-文件权限"><a href="#第七章-文件权限" class="headerlink" title="第七章 文件权限"></a>第七章 文件权限</h2><h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><p>&#x2F;etc&#x2F;passwd文件的字段包含了如下信息：<br> 登录用户名<br> 用户密码<br> 用户账户的UID（数字形式）<br> 用户账户的组ID（GID）（数字形式）<br> 用户账户的文本描述（称为备注字段）<br> 用户HOME目录的位置<br> 用户的默认shell</p>
<p>在&#x2F;etc&#x2F;shadow文件的每条记录中都有9个字段：<br> 与&#x2F;etc&#x2F;passwd文件中的登录名字段对应的登录名<br> 加密后的密码<br> 自上次修改密码后过去的天数密码（自1970年1月1日开始计算）<br> 多少天后才能更改密码<br> 多少天后必须更改密码<br> 密码过期前提前多少天提醒用户更改密码<br> 密码过期后多少天禁用用户账户<br> 用户账户被禁用的日期（用自1970年1月1日到当天的天数表示）<br> 预留字段给将来使用</p>
<h4 id="useadd"><a href="#useadd" class="headerlink" title="useadd"></a>useadd</h4><p>useradd -D 查看添加用户默认值</p>
<p>在创建新用户时，如果你不在命令行中指定具体的值， useradd 命令就会使用 -D 选项所显示<br>的那些默认值。这个例子列出的默认值如下：<br> 新用户会被添加到GID为 100 的公共组；<br> 新用户的HOME目录将会位于&#x2F;home&#x2F;loginname；<br> 新用户账户密码在过期后不会被禁用；<br> 新用户账户未被设置过期日期；<br> 新用户账户将bash shell作为默认shell；<br> 系统会将&#x2F;etc&#x2F;skel目录下的内容复制到用户的HOME目录下；<br> 系统为该用户账户在mail目录下创建一个用于接收邮件的文件。</p>
<p>修改默认值和创建新用户修改参数见书P128 P129</p>
<p>userdel 删除用户，但不会清除用户文件</p>
<p> -r 参数， userdel 会删除用户的HOME目录以及邮件目录</p>
<p><img src="/2022/12/22/%5B%E9%98%85%E8%AF%BB%5D%5B8%5D%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%85%A8%E3%80%8B/image-20221222211243363.png" alt="image-20221222211243363"></p>
<p>chage 命令的日期值可以用下面两种方式中的任意一种：<br> YYYY-MM-DD格式的日期<br> 代表从1970年1月1日起到该日期天数的数值</p>
<p>-I 设置密码过期到锁定账户的天数</p>
<p>chage 命令中有个好用的功能是设置账户的过期日期。有了它，你就能创建在特定日期自动<br>过期的临时用户，再也不需要记住删除用户了！</p>
<h4 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a>usermod</h4><p>-c 修改备注字段， -e 修改过期日期， -g 修改默认的登录组</p>
<p>-l 修改用户账户的登录名。<br><strong>-L 锁定账户，使用户无法登录。</strong><br>-p 修改账户的密码。<br>-U 解除锁定，使用户能够登录<br>-G 组名，将该组添加到用户的属组的列表里，不会影响默认组。</p>
<h3 id="用户组管理"><a href="#用户组管理" class="headerlink" title="用户组管理"></a>用户组管理</h3><p>&#x2F;etc&#x2F;group文件有4个字段：</p>
<p> 组名<br> 组密码<br> GID<br> 属于该组的用户列表</p>
<h4 id="group-add"><a href="#group-add" class="headerlink" title="group add"></a>group add</h4><p>groupadd shared(组名)</p>
<p>usermod -G shared rich<br>usermod 命令的 -G 选项会把这个新组添加到该用户账户的组列表里。</p>
<h4 id="groupmod"><a href="#groupmod" class="headerlink" title="groupmod"></a>groupmod</h4><p>GID（加 -g 选项）或组名（加 -n 选项）。</p>
<p>groupmod -n sharing shared</p>
<h3 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h3><p>输出结果的第一个字段就是描述文件和目录权限的编码。这个字段的第一个字符代表了对象的类型：<br> - 代表文件<br> d 代表目录<br> l 代表链接<br> c 代表字符型设备<br> b 代表块设备<br> n 代表网络设备</p>
<p>rwx</p>
<p>若没有某种权限，在该权限位会出现单破折线。这3组权限分别对应对象的3个安全级别：<br> 对象的属主<br> 对象的属组<br> 系统其他用户</p>
<h4 id="umask"><a href="#umask" class="headerlink" title="umask"></a>umask</h4><p>第一位代表了一项特别的安全特性，叫作粘着位（sticky bit）</p>
<p>先获取这3个 rwx 权限的值，然后将其转换成3位二进制值</p>
<p>umask 值只是个掩码。它会屏蔽掉不想授予该安全级别的权限。</p>
<p>对文件来说，全权限的值是 666 （所有用户都有读和写的权限）；而对目录来说，则是 777 （所有用户都有读、写、执行权限）</p>
<p>用全权限值减去掩码值就是创建新文件或者目录的权限值</p>
<p>目录读权限：表示用户可以用ls命令将目录下的具体子目录和文件罗列出来。</p>
<p>目录写权限：表示用户可以在该目录下可创建子目录或者文件。</p>
<p>目录执行权限：表示可以用cd进入该目录</p>
<h4 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ugoa…][[+-=][rwxXstugo…]</span><br></pre></td></tr></table></figure>

<p>第一组字符定义了权限作用的对象：<br> u 代表用户<br> g 代表组<br> o 代表其他<br> a 代表上述所有</p>
<p>现有权限基础上增加权限（+），还是在现有权限基础上移除权限（-），或是将权限设置成后面的值（&#x3D;）</p>
<p> s ：运行时重新设置UID或GID。<br> u ：将权限设置为跟属主一样。<br> g ：将权限设置为跟属组一样。<br> o ：将权限设置为跟其他用户一样。</p>
<h4 id="chown-chgrp"><a href="#chown-chgrp" class="headerlink" title="chown chgrp"></a>chown chgrp</h4><p>chown 命令用来改变文件的属主，<br>chgrp 命令用来改变文件的默认属组。</p>
<p>chown options owner[.group] file</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">example</span></span><br><span class="line">chown dan newfile</span><br><span class="line">chown dan.shared newfile</span><br></pre></td></tr></table></figure>



<h3 id="共享文件"><a href="#共享文件" class="headerlink" title="共享文件"></a>共享文件</h3><p>想让其他人也能访问文件，要么改变其他用户所在安全组的访问权限，要么就给文件分配一个包含<br>其他用户的新默认属组。如果你想在大范围环境中创建文档并将文档与人共享，这会很烦琐。<br>幸好有一种简单的方法可以解决这个问题。</p>
<p>Linux还为每个文件和目录存储了3个额外的信息位。<br> 设置用户ID（SUID）：当文件被用户使用时，程序会以文件属主的权限运行。<br> 设置组ID（SGID）：对文件来说，程序会以文件属组的权限运行；对目录来说，目录中创建的新文件会以目录的默认属组作为默认属组。<br> 粘着位：进程结束后文件还驻留（粘着）在内存中。</p>
<p><strong>SGID位对文件共享非常重要。启用SGID位后，你可以强制在一个共享目录下创建的新文件都属于该目录的属组，这个组也就成为了每个用户的属组。</strong></p>
<p>为了让这个环境能正常工作，所有组成员都需把他们的 umask 值<strong>设置成文件对属组成员可写</strong>。在前面的例子中， umask 改成了 002 ，所以文件对属组是可写的。</p>
<p>SGID可通过 chmod 命令设置。它会加到标准3位八进制值之前（组成4位八进制值），或者在<br>符号模式下用符号 s 。</p>
<p><img src="/2022/12/22/%5B%E9%98%85%E8%AF%BB%5D%5B8%5D%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%85%A8%E3%80%8B/image-20221222224248450.png" alt="image-20221222224248450"></p>
<h2 id="第八章-管理文件系统"><a href="#第八章-管理文件系统" class="headerlink" title="第八章 管理文件系统"></a>第八章 管理文件系统</h2><p>文件系统通过索引节点号而不是文件全名及路径来标识文件。</p>
<p>ext文件系统名称中的extended部分来自其跟踪的每个文件的额外数据，包括：<br> 文件名<br> 文件大小<br> 文件的属主<br> 文件的属组<br> 文件的访问权限<br> 指向存有文件数据的每个硬盘块的指针</p>
<h3 id="日志文件系统"><a href="#日志文件系统" class="headerlink" title="日志文件系统"></a>日志文件系统</h3><p>日志文件系统为Linux系统增加了一层安全性。它不再使用之前先将数据直接写入存储设备<br>再更新索引节点表的做法，而是先将文件的更改写入到临时文件（称作日志，journal）中。</p>
<p>在数据成功写到存储设备和索引节点表之后，再删除对应的日志条目。</p>
<p><img src="/2022/12/22/%5B%E9%98%85%E8%AF%BB%5D%5B8%5D%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%85%A8%E3%80%8B/image-20221222230009221.png" alt="image-20221222230009221"></p>
<h3 id="写时复制文件系统"><a href="#写时复制文件系统" class="headerlink" title="写时复制文件系统"></a>写时复制文件系统</h3><p>ZFS是一个稳定的文件系统，与Resier4、Btrfs和ext4势均力敌。</p>
<h3 id="创建分区"><a href="#创建分区" class="headerlink" title="创建分区"></a>创建分区</h3><h4 id="fdisk"><a href="#fdisk" class="headerlink" title="fdisk"></a>fdisk</h4><p>sudo fdisk -l 查看信息</p>
<p>sudo fdisk &#x2F;dev&#x2F;sdb(新插入的硬盘)</p>
<p>comand: m (help) , n (创建新分区) ， p(展示信息)，q(不保存退出)，w(保存退出)</p>
<h3 id="创建文件系统"><a href="#创建文件系统" class="headerlink" title="创建文件系统"></a>创建文件系统</h3><p><img src="/2022/12/22/%5B%E9%98%85%E8%AF%BB%5D%5B8%5D%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%85%A8%E3%80%8B/image-20221223141859380.png" alt="image-20221223141859380"></p>
<p>可用type 命令寻找</p>
<p>sudo mkfs.ext4 &#x2F;dev&#x2F;sdb1</p>
<p>sudo mount -t ext4 &#x2F;dev&#x2F;sdb1 &#x2F;mnt&#x2F;my_partition</p>
<h3 id="逻辑卷管理"><a href="#逻辑卷管理" class="headerlink" title="逻辑卷管理"></a>逻辑卷管理</h3><p><img src="/2022/12/22/%5B%E9%98%85%E8%AF%BB%5D%5B8%5D%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%85%A8%E3%80%8B/image-20221223143341085.png" alt="image-20221223143341085"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">从硬盘 上定义物理卷 pv</span></span><br><span class="line"></span><br><span class="line">sudo fdisk  /dev/sdb (t 修改类型， 8e lvm系统) 产生新的分区sdb1</span><br><span class="line"></span><br><span class="line">sudo pvcreate /dev/sdb1</span><br><span class="line"></span><br><span class="line">sudo pvdisplay /dev/sdb1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将物理卷加入卷组  vg</span></span><br><span class="line">sudo vgcreate Vol1 /dev/sdb1</span><br><span class="line">sudo vgdisplay Vol1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">从卷组创建逻辑卷 lv</span></span><br><span class="line">sudo lvcreate -l 100%FREE -n lvtest Vol1</span><br><span class="line">sudo lvdisplay Vol1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">逻辑卷可视为物理卷，创建文件系统，并挂载使用</span></span><br><span class="line">sudo mkfs.ext4 /dev/Vol1/lvtest</span><br><span class="line">sudo mount /dev/Vol1/lvtest /mnt/my_partition</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>修改逻辑卷的命令，不会用，做个记录就好</p>
<p><img src="/2022/12/22/%5B%E9%98%85%E8%AF%BB%5D%5B8%5D%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%85%A8%E3%80%8B/image-20221223150543794.png" alt="image-20221223150543794"></p>
<h2 id="第九章-安装软件程序"><a href="#第九章-安装软件程序" class="headerlink" title="第九章 安装软件程序"></a>第九章 安装软件程序</h2><p>包管理系统 PMS，广泛使用的PMS基础工具是 dpkg 和 rpm</p>
<h3 id="基于-Debian-的系统"><a href="#基于-Debian-的系统" class="headerlink" title="基于 Debian 的系统"></a>基于 Debian 的系统</h3><p>dpkg 命令是基于Debian系PMS工具的核心。包含在这个PMS中的其他工具有：<br> apt-get<br> apt-cache<br> aptitude</p>
<p>aptitude show package_name</p>
<p>所有跟某个特定软件包相关的所有文件的列表</p>
<p>dpkg -L package_name</p>
<p>同样可以进行反向操作，查找某个特定文件属于哪个软件包。注意，在使用的时候必须用绝对文件路径。<br>dpkg –search absolute_file_name</p>
<p>aptitude search package_name</p>
<p>在每个包名字之前都有一个 p 或 i 。如果看到一个 i ，说明这个包现在已经安装到了你<br>的系统上了。如果看到一个 p 或 v ，说明这个包可用，但还没安装。</p>
<p>aptitude safe-upgrade</p>
<p>还有一些不那么保守的软件升级选项：<br> aptitude full-upgrade<br> aptitude dist-upgrade</p>
<p>要想只删除软件包而不删除数据和配置文件，可以使用 aptitude 的 remove 选项。要删除软<br>件包和相关的数据和配置文件，可用 purge 选项。</p>
<p>sudo aptitude purge wine</p>
<p>要看软件包是否已删除，可以再用 aptitude 的 search 选项。如果在软件包名称的前面看到<br>一个 c ，意味着软件已删除，但配置文件尚未从系统中清除；如果前面是个 p 的话，说明配置文件<br>也已删除。</p>
<h2 id="第十章-编辑器"><a href="#第十章-编辑器" class="headerlink" title="第十章 编辑器"></a>第十章 编辑器</h2><p>ctrl + s 是锁定屏幕，</p>
<p>ctrl + q 可以解锁</p>
<p>ctrl + z 放入后台，使用 fg job_num 可以解决</p>
<p>啥都不说了，用gedit就得了</p>
<h1 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h1><h2 id="第十一章-基本脚本"><a href="#第十一章-基本脚本" class="headerlink" title="第十一章 基本脚本"></a>第十一章 基本脚本</h2><p>引用一个变量值时需要使用美元符，而引用变量来对其进行赋值时则不要使用美元符。</p>
<h3 id="命令替换"><a href="#命令替换" class="headerlink" title="命令替换"></a>命令替换</h3><p>有两种方法可以将命令输出赋给变量：<br> 反引号字符（ &#96; ）<br> $() 格式</p>
<p>example:</p>
<p>​	$(date)</p>
<p>命令替换会创建一个子shell来运行对应的命令。子shell（subshell）是由运行该脚本的shell<br>所创建出来的一个独立的子shell（child shell）。正因如此，由该子shell所执行命令是无法<br>使用脚本中所创建的变量的。</p>
<p>在命令行提示符下使用路径 .&#x2F; 运行命令的话，也会创建出子shell；要是运行命令的时候<br>不加入路径，就不会创建子shell。如果你使用的是内建的shell命令，并不会涉及子shell。<br>在命令行提示符下运行脚本时一定要留心！</p>
<h3 id="IO重定向"><a href="#IO重定向" class="headerlink" title="IO重定向"></a>IO重定向</h3><p>如果输出文件已经存在了，重定向操作符会用新的文件数据覆盖已有文件。</p>
<p>可以用双大于号（&gt;&gt;）来追加数据</p>
<p>输入重定向 &lt;</p>
<p>wc 命令可以对对数据中的文本进行计数。默认情况下，它会输出3个值：<br> 文本的行数<br> 文本的词数<br> 文本的字节数</p>
<p>内联输入重定向符号是远小于号（&lt;&lt;）。</p>
<p>command &lt;&lt; marker<br>data<br>marker</p>
<p><img src="/2022/12/22/%5B%E9%98%85%E8%AF%BB%5D%5B8%5D%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%85%A8%E3%80%8B/image-20221223215409327.png" alt="image-20221223215409327"></p>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>command1 | command2</p>
<p>Linux系统实际上会同时运行这两个命令，在系统内部将它们连接起来。</p>
<p>在第一个命令产生输出的同时，输出会被立即送给第二个命令。</p>
<p>数据传输不会用到任何中间文件或缓冲区。</p>
<p>管道最流行的用法之一是将命令产生的大量输出通过管道传送给 more 命令。<br>通过将输出管道连接到 more 命令，可以强制输出在一屏数据显示后停下来。</p>
<h3 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h3><p>expr 命令，太拉胯，还是不要用了</p>
<p>在bash中，在将一个数学运算结果赋给某个变量时，可以用美元符和方括号（ $[ operation ] ）将数学表达式围起来。</p>
<p>bash shell数学运算符只支持整数运算。若要进行任何实际的数学计算，这是一个巨大的限制。</p>
<p>z shell（zsh）提供了完整的浮点数算术操作。</p>
<p>bc解决方案，-q 快速启动</p>
<p>variable&#x3D;$(echo “options; expression” | bc)</p>
<p>最好的办法是使用内联输入重定向，它允许你直接在命令行中重定向数据。在shell脚本中，<br>你可以将输出赋给一个变量。</p>
<p>variable&#x3D;$(bc &lt;&lt; EOF<br>options<br>statements<br>expressions<br>EOF<br>)</p>
<p>你还会注意到，在这个例子中，你可以在bash计算器中赋值给变量。这一点很重要：在bash<br>计算器中创建的变量只在bash计算器中有效，不能在shell脚本中使用</p>
<h3 id="退出脚本"><a href="#退出脚本" class="headerlink" title="退出脚本"></a>退出脚本</h3><p>必须在其运行完毕后立刻查看或使用 $? 变量。它的值会变成由shell所执行的最后一条命令的退出状态码。</p>
<p><img src="/2022/12/22/%5B%E9%98%85%E8%AF%BB%5D%5B8%5D%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%85%A8%E3%80%8B/image-20221223222203304.png" alt="image-20221223222203304"></p>
<p>默认情况下，shell脚本会以脚本中的最后一个命令的退出状态码退出。</p>
<p> exit 命令允许你在脚本结束时指定一个退出状态码,也可以在 exit 命令的参数中使用变量。</p>
<p>退出状态码被缩减到了0～255的区间。shell通过模运算得到这个结果。一个值的模就是被除<br>后的余数。最终的结果是指定的数值除以256后得到的余数。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看退出状态</span></span><br><span class="line">echo $? </span><br></pre></td></tr></table></figure>



<h2 id="第十二章-使用结构化命令"><a href="#第十二章-使用结构化命令" class="headerlink" title="第十二章 使用结构化命令"></a>第十二章 使用结构化命令</h2><h3 id="if-then"><a href="#if-then" class="headerlink" title="if-then"></a>if-then</h3><p>最基本的结构化命令就是 if-then 语句。 if-then 语句有如下格式。<br>if command<br>then<br>    commands<br>fi</p>
<p>如果该命令的退出状态码（参见第11章）是 0（该命令成功运行），位于 then 部分的命令就会被执行。</p>
<p>如果该命令的退出状态码是其他值， then部分的命令就不会被执行，bash shell会继续执行脚本中的下一个命令。 </p>
<p> fi 语句用来表示 if-then语句到此结束。</p>
<p>有时你可能不想看到错误信息。第15章将会讨论如何避免这种情况。</p>
<p>你可能在有些脚本中看到过 if-then 语句的另一种形式：<br>if command; then<br>    commands<br>fi<br>通过把分号放在待求值的命令尾部，就可以将 then 语句放在同一行上了，这样看起来更<br>像其他编程语言中的 if-then 语句。</p>
<h3 id="if-then-else"><a href="#if-then-else" class="headerlink" title="if-then-else"></a>if-then-else</h3><p>if command<br>then<br>   commands<br>else<br>   commands<br>fi</p>
<h3 id="if-then-elif-then"><a href="#if-then-elif-then" class="headerlink" title="if then elif then"></a>if then elif then</h3><p>if command1<br>then<br>   commands<br>elif command2<br>then<br>    more commands<br>fi</p>
<p>还可以嵌套多个 elif 和 else</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">可以继续将多个 elif 语句串起来，形成一个大的 if-then-elif 嵌套组合。</span><br><span class="line">if command1</span><br><span class="line">then</span><br><span class="line">	command set 1</span><br><span class="line">elif command2</span><br><span class="line">then</span><br><span class="line">	command set 2</span><br><span class="line">elif command3</span><br><span class="line">then</span><br><span class="line">	command set 3</span><br><span class="line">elif command4</span><br><span class="line">then</span><br><span class="line">	command set 4</span><br><span class="line">else</span><br><span class="line">	command set 5</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>每块命令都会根据命令是否会返回退出状态码 0 来执行。记住，bash shell会依次执行 if 语句，<br>只有第一个返回退出状态码 0 的语句中的 then 部分会被执行。</p>
<h3 id="test命令"><a href="#test命令" class="headerlink" title="test命令"></a>test命令</h3><p>test 命令提供了在 if-then 语句中测试不同条件的途径。如果 test 命令中列出的条件成立，test 命令就会退出并返回退出状态码 0 。</p>
<p>这样 if-then 语句就与其他编程语言中的 if-then 语句以类似的方式工作了。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if test condition</span><br><span class="line">then</span><br><span class="line">	commands</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>如果不写 test 命令的 condition 部分，它会以非零的退出状态码退出，并执行 else 语句块。</p>
<p>bash shell提供了另一种条件测试方法，无需在 if-then 语句中声明 test 命令。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if [ condition ]</span><br><span class="line">then</span><br><span class="line">	commands</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>第一个方括号之后和第二个方括号之前必须加上一个空格，否则就会报错。</p>
<p>test 命令可以判断三类条件：<br> 数值比较<br> 字符串比较<br> 文件比较</p>
<p><img src="/2022/12/22/%5B%E9%98%85%E8%AF%BB%5D%5B8%5D%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%85%A8%E3%80%8B/image-20221224160901450.png" alt="image-20221224160901450"></p>
<p>但是涉及浮点值时，数值条件测试会有一个限制。</p>
<p>bash shell只能处理整数。如果你只是要通过 echo 语句来显示这个结果，那没问题。但是，在基于数字的函数中就不行了</p>
<p><img src="/2022/12/22/%5B%E9%98%85%E8%AF%BB%5D%5B8%5D%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%85%A8%E3%80%8B/image-20221224161653901.png" alt="image-20221224161653901"></p>
<p>大于号和小于号<strong>必须转义</strong>，否则shell会把它们当作重定向符号，把字符串值当作文件名；</p>
<p>大于和小于顺序和 sort 命令所采用的不同</p>
<p>比较测试中使用的是标准的ASCII顺序，根据每个字符的ASCII数值来决定排序结果。</p>
<p>sort命令使用的是系统的本地化语言设置中定义的排序顺序。</p>
<p>这个变量并未在shell脚本中定义过，所以它的字符串长度仍然为0</p>
<p><img src="/2022/12/22/%5B%E9%98%85%E8%AF%BB%5D%5B8%5D%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%85%A8%E3%80%8B/image-20221224163611079.png" alt="image-20221224163611079"></p>
<h3 id="复合条件测试"><a href="#复合条件测试" class="headerlink" title="复合条件测试"></a>复合条件测试</h3><p>if-then 语句允许你使用布尔逻辑来组合测试。有两种布尔运算符可用：<br> [ condition1 ] &amp;&amp; [ condition2 ]<br> [ condition1 ] || [ condition2 ]</p>
<h3 id="fi-then-高级特性"><a href="#fi-then-高级特性" class="headerlink" title="fi-then 高级特性"></a>fi-then 高级特性</h3><p>双括号在比较过程中使用高级数学表达式</p>
<p>(( expression ))</p>
<p><img src="/2022/12/22/%5B%E9%98%85%E8%AF%BB%5D%5B8%5D%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%85%A8%E3%80%8B/image-20221224204654127.png" alt="image-20221224204654127"></p>
<p>不需要将双括号中表达式里的大于号转义。这是双括号命令提供的另一个高级特性</p>
<p>双方括号命令提供了针对字符串比较的高级特性。</p>
<p>[[ expression ]]</p>
<h3 id="case-命令"><a href="#case-命令" class="headerlink" title="case 命令"></a>case 命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">case variable in</span><br><span class="line">pattern1 | pattern2 ) commands1 ;;</span><br><span class="line">pattern3 ) commands2 ;;</span><br><span class="line">*) default commands ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>



<p>case 命令会将指定的变量与不同模式进行比较。如果变量和模式是匹配的，那么shell会执行<br>为该模式指定的命令。</p>
<h2 id="第十三章-更多结构化命令"><a href="#第十三章-更多结构化命令" class="headerlink" title="第十三章 更多结构化命令"></a>第十三章 更多结构化命令</h2><h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for var in list</span><br><span class="line">do</span><br><span class="line">commands</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>只要你愿意，也可以将 do 语句和 for 语句放在同一行，<br>但必须用分号将其同列表中的值分开： for var in list; do 。</p>
<p>var会一直保持最后一次迭代的值（除非你修改了它）</p>
<h4 id="读取复杂值，带引号等"><a href="#读取复杂值，带引号等" class="headerlink" title="读取复杂值，带引号等"></a>读取复杂值，带引号等</h4><p>有两种办法可解决这个问题：<br> 使用转义字符（反斜线）来将单引号转义；<br> 使用双引号来定义用到单引号的值。</p>
<p>记住， for 循环假定每个值都是用空格分割的。如果有包含空格的数据值，你就陷入麻烦了。<br>在某个值两边使用双引号时，shell并不会将双引号当成值的一部分。</p>
<h4 id="从变量读取值"><a href="#从变量读取值" class="headerlink" title="从变量读取值"></a>从变量读取值</h4><p>通常shell脚本遇到的情况是，你将一系列值都集中存储在了一个变量中，然后需要遍历变量<br>中的整个列表。也可以通过 for 命令完成这个任务。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">向变量中存储的已有文本字符串尾部添加文本的一个常用方法</span></span><br><span class="line">list=&quot;Alabama Alaska Arizona Arkansas Colorado&quot;</span><br><span class="line">list=$list&quot; Connecticut&quot;</span><br></pre></td></tr></table></figure>





<h4 id="从命令读取值"><a href="#从命令读取值" class="headerlink" title="从命令读取值"></a>从命令读取值</h4><p>for state in $(cat  $file)</p>
<p>默认情况下，bash shell会将下列字符当作字段分隔符：<br> 空格<br> 制表符<br> 换行符</p>
<p>可以在shell脚本中临时更改 IFS 环境变量的值来限制被bash shell当作字段<br>分隔符的字符。</p>
<p>IFS&#x3D;$’\n’</p>
<h4 id="用通配符读取目录"><a href="#用通配符读取目录" class="headerlink" title="用通配符读取目录"></a>用通配符读取目录</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for file in /home/rich/.b* /home/rich/badtest</span><br><span class="line">do</span><br><span class="line">	......</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>在Linux中，目录名和文件名中包含空格当然是合法的。要适应这种情况，应该将 $file 变量用双引号圈起来。</p>
<h4 id="C-语言风格for-循环"><a href="#C-语言风格for-循环" class="headerlink" title="C 语言风格for 循环"></a>C 语言风格for 循环</h4><p>for (( variable assignment ; condition ; iteration process ))</p>
<p>尽管可以使用多个变量，但你只能在 for 循环中定义一种条件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">multiple variables</span></span><br><span class="line">for (( a=1, b=10; a &lt;= 10; a++, b-- ))</span><br><span class="line">do</span><br><span class="line">	echo &quot;$a - $b&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>





<h3 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h3><p>它会在每次迭代的<br>一开始测试 test 命令。在 test 命令返回非零退出状态码时， while 命令会停止执行那组命令。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while test command</span><br><span class="line">do</span><br><span class="line">	other commands</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>while 命令中定义的 test command 和 if-then 语句（参见第12章）中的格式一模一样。</p>
<p>while 命令的关键在于所指定的 test command 的退出状态码必须随着循环中运行的命令而改变。</p>
<p>while 命令允许你在 while 语句行定义多个测试命令。只有<strong>最后一个测试命令</strong>的退出状态码会被用来决定什么时候结束循环。</p>
<h3 id="until-命令"><a href="#until-命令" class="headerlink" title="until 命令"></a>until 命令</h3><p>until 命令和 while 命令工作的方式完全相反。 until 命令要求你指定一个通常返回非零退<br>出状态码的测试命令。只有测试命令的退出状态码不为 0 ，bash shell才会执行循环中列出的命令。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">until test commands</span><br><span class="line">do</span><br><span class="line">	other commands</span><br><span class="line">done</span><br></pre></td></tr></table></figure>



<h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p>在处理多个循环时， break 命令会自动终止你所在的最内层的循环。</p>
<p>有时你在内部循环，但需要停止外部循环。 break 命令接受单个命令行参数值</p>
<p>其中 n 指定了要跳出的循环层级。默认情况下， n 为 1 ，表明跳出的是当前的循环。</p>
<p>如果你将n 设为 2 ， break 命令就会停止下一级的外部循环</p>
<h3 id="处理循环输出"><a href="#处理循环输出" class="headerlink" title="处理循环输出"></a>处理循环输出</h3><p>最后，在shell脚本中，你可以对循环的输出使用管道或进行重定向。这可以通过在 done 命令<br>之后添加一个处理命令来实现。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>使用 read 命令读取文件中的各行</p>
<h2 id="第十四章-处理用户输入"><a href="#第十四章-处理用户输入" class="headerlink" title="第十四章 处理用户输入"></a>第十四章 处理用户输入</h2><h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><p>位置参数变量是标准的数字： $0 是程序名， $1 是第一个参数， $2 是第二个参数，依次类推，直到第九个参数 $9 。</p>
<p> $0 参数获取shell在命令行启动的脚本名</p>
<p>当传给 $0 变量的实际字符串不仅仅是脚本名，而是完整的脚本路径时，<br>变量 $0 就会使用整个路径。</p>
<p>在shell脚本中使用命令行参数时要小心些。如果脚本不加参数运行，可能会出问题</p>
<p>在使用参数前一定要检查其中是否存在数据。</p>
<h4 id="参数个数"><a href="#参数个数" class="headerlink" title="参数个数"></a>参数个数</h4><p>特殊变量 $# 含有脚本运行时携带的命令行参数的个数。</p>
<p>这个变量还提供了一个简便方法来获取命令行中最后一个参数 即 <img src="/2022/12/22/%5B%E9%98%85%E8%AF%BB%5D%5B8%5D%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%85%A8%E3%80%8B/image-20221227161845392.png" alt="image-20221227161845392"></p>
<p><img src="/2022/12/22/%5B%E9%98%85%E8%AF%BB%5D%5B8%5D%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%85%A8%E3%80%8B/image-20221227161755238.png" alt="image-20221227161755238"></p>
<h4 id="抓取所有数据"><a href="#抓取所有数据" class="headerlink" title="抓取所有数据"></a>抓取所有数据</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">* 和 <span class="variable">$@</span> 变量可以用来轻松访问所有的参数。这两个变量都能够在单个变量中存储所有的命令行参数。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">* 变量会将命令行上提供的所有参数当作一个单词保存。这个单词包含了命令行中出现的每一个参数值。</span></span><br><span class="line">基本上 $* 变量会将这些参数视为一个整体，而不是多个个体。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">@ 变量会将命令行上提供的所有参数当作同一字符串中的多个独立的单词。</span></span><br><span class="line">这样你就能够遍历所有的参数值，得到每个参数。这通常通过 for 命令完成。</span><br></pre></td></tr></table></figure>



<h4 id="移动变量"><a href="#移动变量" class="headerlink" title="移动变量"></a>移动变量</h4><p>在使用 shift 命令时，默认情况下它会将每个参数变量向左移动一个位置。所以，变量 $3<br>的值会移到 $2 中，变量 $2 的值会移到 $1 中，而变量 $1 的值则会被删除（注意，变量 $0 的值，也就是程序名，不会改变）。</p>
<p>你也可以一次性移动多个位置，只需要给 shift 命令提供一个参数，指明要移动的位置数就行了。</p>
<p>shift 2</p>
<p>通过使用 shift 命令的参数，就可以轻松地跳过不需要的参数。</p>
<h3 id="处理选项"><a href="#处理选项" class="headerlink" title="处理选项"></a>处理选项</h3><p>分离参数和选项使用 –</p>
<p>使用 case  $1 shift 格式逐一处理</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">while [ -n &quot;$1&quot; ]</span><br><span class="line">do</span><br><span class="line">	case &quot;$1&quot; in</span><br><span class="line">	-a) echo &quot;Found the -a option&quot; ;;</span><br><span class="line">	-b) param=&quot;$2&quot; # 带参数</span><br><span class="line">		echo &quot;Found the -b option, with parameter value $param&quot;</span><br><span class="line">		shift ;;</span><br><span class="line">	-c) echo &quot;Found the -c option&quot; ;;</span><br><span class="line">	--) shift</span><br><span class="line">		break ;;</span><br><span class="line">	*) echo &quot;$1 is not an option&quot;;;</span><br><span class="line">	esac</span><br><span class="line">	shift</span><br><span class="line">done</span><br></pre></td></tr></table></figure>



<h4 id="使用-getopt-命令"><a href="#使用-getopt-命令" class="headerlink" title="使用 getopt 命令"></a>使用 getopt 命令</h4><p>格式 getopt optstring parameters</p>
<p>在 optstring 中列出你要在脚本中用到的每个命令行选项字母。</p>
<p>然后，在每个需要参数值的选项字母后加一个冒号。 </p>
<p>getopt 命令会基于你定义的 optstring 解析提供的参数。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">getopt ab:<span class="built_in">cd</span> -a -b test1 -<span class="built_in">cd</span> -e test2 test3</span></span><br><span class="line">getopt: invalid option -- &#x27;e&#x27;</span><br><span class="line"> -a -b test1 -c -d -- test2 test3</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-q 忽略报错</span></span><br></pre></td></tr></table></figure>



<p>set 命令的选项之一是双破折线（ – ），它会将命令行参数替换成 set 命令的命令行值。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set -- $(getopt -q ab:cd &quot;$@&quot;)</span><br></pre></td></tr></table></figure>



<p>getopt 命令并不擅长处理带空格和引号的参数值。它会将空格当作参数分隔符，而不是根据双引号将二者当作一个参数。</p>
<h4 id="使用更高级的-getopts"><a href="#使用更高级的-getopts" class="headerlink" title="使用更高级的 getopts"></a>使用更高级的 getopts</h4><p>getopts 命令（注意是复数）内建于bash shell。</p>
<p>每次调用它时，它一次只处理命令行上检测到的一个参数。处理完所有的参数后，它会退出<br>并返回一个大于0的退出状态码。这让它非常适合用解析命令行所有参数的循环中。</p>
<p>getopts 命令的格式如下：<br>getopts optstring variable</p>
<p>有效的选项字母都会列在 optstring 中，<br>如果选项字母要求有个参数值，就加一个冒号。要去掉错误消息的话，可以在 optstring 之前加一个冒号。<br>getopts 命令将当前参数保存在命令行中定义的 variable 中。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">while getopts :ab:c opt</span><br><span class="line">do</span><br><span class="line">	case &quot;$opt&quot; in</span><br><span class="line">	a)  ;;</span><br><span class="line">	b) echo &quot;Found the -b option, with value $OPTARG&quot; ;; # 选项参数</span><br><span class="line">	.....</span><br><span class="line">	*)  ;;</span><br><span class="line">	esac</span><br><span class="line"></span><br><span class="line">done</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">opt处理结束后，处理param</span></span><br><span class="line">shift $[ $OPTIND - 1 ]</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>getopts 命令解析命令行选项时会移除开头的单破折线，所以在 case 定义中不用单破折线。</p>
<p>getopts 命令会用到两个环境变量。<br>如果选项需要跟一个参数值， OPTARG 环境变量就会保存这个值。<br>OPTIND 环境变量保存了参数列表中 getopts 正在处理的参数位置。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可以在参数值中包含空格。</span></span><br><span class="line">./test19.sh -b &quot;test1 test2&quot; -a</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">另一个好用的功能是将选项字母和参数值放在一起使用，而不用加空格。</span></span><br><span class="line">./test19.sh -abtest1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> <span class="built_in">getopts</span> 还能够将命令行上找到的所有未定义的选项统一输出成问号。</span></span><br></pre></td></tr></table></figure>



<p>getopts 命令知道何时停止处理选项，并将参数留给你处理。</p>
<p>在 getopts 处理每个选项时，它会将 OPTIND 环境变量值增一。<br>在 getopts 完成处理时，你可以使用 shift 命令和 OPTIND 值来移动参数。</p>
<p>注意 OPTIND 需要减一才能 匹配上处理的参数</p>
<h4 id="标准化选项"><a href="#标准化选项" class="headerlink" title="标准化选项"></a>标准化选项</h4><p><img src="/2022/12/22/%5B%E9%98%85%E8%AF%BB%5D%5B8%5D%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%85%A8%E3%80%8B/image-20221227152446122.png" alt="image-20221227152446122"></p>
<h3 id="获取用户输入"><a href="#获取用户输入" class="headerlink" title="获取用户输入"></a>获取用户输入</h3><h4 id="基本读取"><a href="#基本读取" class="headerlink" title="基本读取"></a>基本读取</h4><p>read 命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">echo -n &quot;Enter your name: &quot;</span><br><span class="line">read name</span><br><span class="line"></span><br><span class="line">read -p &quot;Please enter your age: &quot; age</span><br></pre></td></tr></table></figure>

<p>read 命令会将提示符后输入的所有数据分配给单个变量，要么你就指定多个变量。输入的每个<br>数据值都会分配给变量列表中的下一个变量。如果变量数量不够，剩下的数据就全部分配给最后<br>一个变量。</p>
<p>也可以不指定变量，read 命令会将它收到的任何数据都放进特殊环境变量 REPLY 中</p>
<h4 id="超时和限长"><a href="#超时和限长" class="headerlink" title="超时和限长"></a>超时和限长</h4><p>你可以用 -t 选项来指定一个计时器。 -t 选项指定了 read 命令等待输入的秒数。当计时器过期后， read 命令会返回一个非零退出状态码。</p>
<p>让 read 命令来统计输入的字符数。当输入的字符达到预设的字符数时，就自动退出，将输入的数据赋给变量。</p>
<h4 id="隐藏方式读取"><a href="#隐藏方式读取" class="headerlink" title="隐藏方式读取"></a>隐藏方式读取</h4><p>-s 选项可以避免在 read 命令中输入的数据出现在显示器上</p>
<h4 id="从文件中读取"><a href="#从文件中读取" class="headerlink" title="从文件中读取"></a>从文件中读取</h4><p>每次调用 read 命令，它都会从文件中读取一行文本。</p>
<p>当文件中再没有内容时， read 命令会退出并返回非零退出状态码。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat test | while read line</span><br><span class="line">do</span><br><span class="line">......</span><br><span class="line">done</span><br></pre></td></tr></table></figure>



<h2 id="第十五章-呈现数据"><a href="#第十五章-呈现数据" class="headerlink" title="第十五章 呈现数据"></a>第十五章 呈现数据</h2>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" rel="tag"># 学习记录</a>
              <a href="/tags/shell/" rel="tag"># shell</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/11/24/%5B%E6%96%87%E5%A8%B1%5D%5B%E7%94%B5%E5%BD%B1%5D/" rel="prev" title="文娱电影">
      <i class="fa fa-chevron-left"></i> 文娱电影
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BC%98%E8%B5%B7"><span class="nav-number">1.</span> <span class="nav-text">缘起</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86"><span class="nav-number">2.</span> <span class="nav-text">第一部分</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0"><span class="nav-number">2.1.</span> <span class="nav-text">第二章</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%9F%BA%E6%9C%ACbash-shell-%E5%91%BD%E4%BB%A4"><span class="nav-number">2.2.</span> <span class="nav-text">第三章 基本bash shell 命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%9B%B4%E5%A4%9Abash-shell-%E7%9B%91%E6%8E%A7%E5%92%8C%E5%A4%84%E7%90%86"><span class="nav-number">2.3.</span> <span class="nav-text">第四章 更多bash shell 监控和处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ps-%E5%91%BD%E4%BB%A4"><span class="nav-number">2.3.1.</span> <span class="nav-text">ps 命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#top-%E5%91%BD%E4%BB%A4"><span class="nav-number">2.3.2.</span> <span class="nav-text">top 命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#kill-%E5%91%BD%E4%BB%A4"><span class="nav-number">2.3.3.</span> <span class="nav-text">kill 命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mount-%E5%91%BD%E4%BB%A4"><span class="nav-number">2.3.4.</span> <span class="nav-text">mount 命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#df-du-%E5%92%8C-dd%E5%91%BD%E4%BB%A4"><span class="nav-number">2.3.5.</span> <span class="nav-text">df du 和 dd命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sort-%E6%95%B0%E6%8D%AE%E6%8E%92%E5%BA%8F"><span class="nav-number">2.3.6.</span> <span class="nav-text">sort 数据排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#grep-%E6%90%9C%E7%B4%A2%E6%95%B0%E6%8D%AE"><span class="nav-number">2.3.7.</span> <span class="nav-text">grep 搜索数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tar-%E5%BD%92%E6%A1%A3%E6%95%B0%E6%8D%AE"><span class="nav-number">2.3.8.</span> <span class="nav-text">tar 归档数据</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%90%86%E8%A7%A3shell"><span class="nav-number">2.4.</span> <span class="nav-text">第五章 理解shell</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#history"><span class="nav-number">2.4.1.</span> <span class="nav-text">history</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#alias-%E5%91%BD%E4%BB%A4%E5%88%AB%E5%90%8D"><span class="nav-number">2.4.2.</span> <span class="nav-text">alias 命令别名</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="nav-number">2.5.</span> <span class="nav-text">第六章 环境变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#PATH%E5%8F%98%E9%87%8F"><span class="nav-number">2.5.1.</span> <span class="nav-text">PATH变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="nav-number">2.5.2.</span> <span class="nav-text">持久化环境变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%8F%98%E9%87%8F"><span class="nav-number">2.5.3.</span> <span class="nav-text">数组变量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90"><span class="nav-number">2.6.</span> <span class="nav-text">第七章 文件权限</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86"><span class="nav-number">2.6.1.</span> <span class="nav-text">用户管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#useadd"><span class="nav-number">2.6.1.1.</span> <span class="nav-text">useadd</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#usermod"><span class="nav-number">2.6.1.2.</span> <span class="nav-text">usermod</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E7%BB%84%E7%AE%A1%E7%90%86"><span class="nav-number">2.6.2.</span> <span class="nav-text">用户组管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#group-add"><span class="nav-number">2.6.2.1.</span> <span class="nav-text">group add</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#groupmod"><span class="nav-number">2.6.2.2.</span> <span class="nav-text">groupmod</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90"><span class="nav-number">2.6.3.</span> <span class="nav-text">文件权限</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#umask"><span class="nav-number">2.6.3.1.</span> <span class="nav-text">umask</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#chmod"><span class="nav-number">2.6.3.2.</span> <span class="nav-text">chmod</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#chown-chgrp"><span class="nav-number">2.6.3.3.</span> <span class="nav-text">chown chgrp</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6"><span class="nav-number">2.6.4.</span> <span class="nav-text">共享文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E7%AE%A1%E7%90%86%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.7.</span> <span class="nav-text">第八章 管理文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.7.1.</span> <span class="nav-text">日志文件系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.7.2.</span> <span class="nav-text">写时复制文件系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%88%86%E5%8C%BA"><span class="nav-number">2.7.3.</span> <span class="nav-text">创建分区</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#fdisk"><span class="nav-number">2.7.3.1.</span> <span class="nav-text">fdisk</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.7.4.</span> <span class="nav-text">创建文件系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E5%8D%B7%E7%AE%A1%E7%90%86"><span class="nav-number">2.7.5.</span> <span class="nav-text">逻辑卷管理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E7%A8%8B%E5%BA%8F"><span class="nav-number">2.8.</span> <span class="nav-text">第九章 安装软件程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E-Debian-%E7%9A%84%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.8.1.</span> <span class="nav-text">基于 Debian 的系统</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0-%E7%BC%96%E8%BE%91%E5%99%A8"><span class="nav-number">2.9.</span> <span class="nav-text">第十章 编辑器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86"><span class="nav-number">3.</span> <span class="nav-text">第二部分</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E5%9F%BA%E6%9C%AC%E8%84%9A%E6%9C%AC"><span class="nav-number">3.1.</span> <span class="nav-text">第十一章 基本脚本</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E6%9B%BF%E6%8D%A2"><span class="nav-number">3.1.1.</span> <span class="nav-text">命令替换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IO%E9%87%8D%E5%AE%9A%E5%90%91"><span class="nav-number">3.1.2.</span> <span class="nav-text">IO重定向</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%A1%E9%81%93"><span class="nav-number">3.1.3.</span> <span class="nav-text">管道</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97"><span class="nav-number">3.1.4.</span> <span class="nav-text">数学运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%80%E5%87%BA%E8%84%9A%E6%9C%AC"><span class="nav-number">3.1.5.</span> <span class="nav-text">退出脚本</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%84%E5%8C%96%E5%91%BD%E4%BB%A4"><span class="nav-number">3.2.</span> <span class="nav-text">第十二章 使用结构化命令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#if-then"><span class="nav-number">3.2.1.</span> <span class="nav-text">if-then</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#if-then-else"><span class="nav-number">3.2.2.</span> <span class="nav-text">if-then-else</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#if-then-elif-then"><span class="nav-number">3.2.3.</span> <span class="nav-text">if then elif then</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#test%E5%91%BD%E4%BB%A4"><span class="nav-number">3.2.4.</span> <span class="nav-text">test命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E5%90%88%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95"><span class="nav-number">3.2.5.</span> <span class="nav-text">复合条件测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fi-then-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7"><span class="nav-number">3.2.6.</span> <span class="nav-text">fi-then 高级特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#case-%E5%91%BD%E4%BB%A4"><span class="nav-number">3.2.7.</span> <span class="nav-text">case 命令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E6%9B%B4%E5%A4%9A%E7%BB%93%E6%9E%84%E5%8C%96%E5%91%BD%E4%BB%A4"><span class="nav-number">3.3.</span> <span class="nav-text">第十三章 更多结构化命令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#for-%E5%BE%AA%E7%8E%AF"><span class="nav-number">3.3.1.</span> <span class="nav-text">for 循环</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E5%8F%96%E5%A4%8D%E6%9D%82%E5%80%BC%EF%BC%8C%E5%B8%A6%E5%BC%95%E5%8F%B7%E7%AD%89"><span class="nav-number">3.3.1.1.</span> <span class="nav-text">读取复杂值，带引号等</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8E%E5%8F%98%E9%87%8F%E8%AF%BB%E5%8F%96%E5%80%BC"><span class="nav-number">3.3.1.2.</span> <span class="nav-text">从变量读取值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8E%E5%91%BD%E4%BB%A4%E8%AF%BB%E5%8F%96%E5%80%BC"><span class="nav-number">3.3.1.3.</span> <span class="nav-text">从命令读取值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E9%80%9A%E9%85%8D%E7%AC%A6%E8%AF%BB%E5%8F%96%E7%9B%AE%E5%BD%95"><span class="nav-number">3.3.1.4.</span> <span class="nav-text">用通配符读取目录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-%E8%AF%AD%E8%A8%80%E9%A3%8E%E6%A0%BCfor-%E5%BE%AA%E7%8E%AF"><span class="nav-number">3.3.1.5.</span> <span class="nav-text">C 语言风格for 循环</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#while-%E5%BE%AA%E7%8E%AF"><span class="nav-number">3.3.2.</span> <span class="nav-text">while 循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#until-%E5%91%BD%E4%BB%A4"><span class="nav-number">3.3.3.</span> <span class="nav-text">until 命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#break"><span class="nav-number">3.3.4.</span> <span class="nav-text">break</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E5%BE%AA%E7%8E%AF%E8%BE%93%E5%87%BA"><span class="nav-number">3.3.5.</span> <span class="nav-text">处理循环输出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B"><span class="nav-number">3.3.6.</span> <span class="nav-text">实例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0-%E5%A4%84%E7%90%86%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5"><span class="nav-number">3.4.</span> <span class="nav-text">第十四章 处理用户输入</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="nav-number">3.4.1.</span> <span class="nav-text">命令行参数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E4%B8%AA%E6%95%B0"><span class="nav-number">3.4.1.1.</span> <span class="nav-text">参数个数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%93%E5%8F%96%E6%89%80%E6%9C%89%E6%95%B0%E6%8D%AE"><span class="nav-number">3.4.1.2.</span> <span class="nav-text">抓取所有数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A7%BB%E5%8A%A8%E5%8F%98%E9%87%8F"><span class="nav-number">3.4.1.3.</span> <span class="nav-text">移动变量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E9%80%89%E9%A1%B9"><span class="nav-number">3.4.2.</span> <span class="nav-text">处理选项</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-getopt-%E5%91%BD%E4%BB%A4"><span class="nav-number">3.4.2.1.</span> <span class="nav-text">使用 getopt 命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%9B%B4%E9%AB%98%E7%BA%A7%E7%9A%84-getopts"><span class="nav-number">3.4.2.2.</span> <span class="nav-text">使用更高级的 getopts</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E5%8C%96%E9%80%89%E9%A1%B9"><span class="nav-number">3.4.2.3.</span> <span class="nav-text">标准化选项</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5"><span class="nav-number">3.4.3.</span> <span class="nav-text">获取用户输入</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%BB%E5%8F%96"><span class="nav-number">3.4.3.1.</span> <span class="nav-text">基本读取</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B6%85%E6%97%B6%E5%92%8C%E9%99%90%E9%95%BF"><span class="nav-number">3.4.3.2.</span> <span class="nav-text">超时和限长</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%90%E8%97%8F%E6%96%B9%E5%BC%8F%E8%AF%BB%E5%8F%96"><span class="nav-number">3.4.3.3.</span> <span class="nav-text">隐藏方式读取</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8E%E6%96%87%E4%BB%B6%E4%B8%AD%E8%AF%BB%E5%8F%96"><span class="nav-number">3.4.3.4.</span> <span class="nav-text">从文件中读取</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0-%E5%91%88%E7%8E%B0%E6%95%B0%E6%8D%AE"><span class="nav-number">3.5.</span> <span class="nav-text">第十五章 呈现数据</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">fea01</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">24</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fea01</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
