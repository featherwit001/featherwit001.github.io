<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="写在前面Rust 学习曲线陡峭，每次都去查Rust 程序设计语言,有点麻烦，集中记录一些常用的点。">
<meta property="og:type" content="article">
<meta property="og:title" content="[备忘录][Rust]">
<meta property="og:url" content="http://example.com/2022/07/22/[%E5%A4%87%E5%BF%98%E5%BD%95][Rust]/index.html">
<meta property="og:site_name" content="学海注">
<meta property="og:description" content="写在前面Rust 学习曲线陡峭，每次都去查Rust 程序设计语言,有点麻烦，集中记录一些常用的点。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2022/07/22/%5B%E5%A4%87%E5%BF%98%E5%BD%95%5D%5BRust%5D/image-20220727190406930.png">
<meta property="og:image" content="http://example.com/2022/07/22/%5B%E5%A4%87%E5%BF%98%E5%BD%95%5D%5BRust%5D/image-20220728124705531.png">
<meta property="og:image" content="http://example.com/2022/07/22/%5B%E5%A4%87%E5%BF%98%E5%BD%95%5D%5BRust%5D/image-20220806180613257.png">
<meta property="og:image" content="http://example.com/2022/07/22/%5B%E5%A4%87%E5%BF%98%E5%BD%95%5D%5BRust%5D/image-20220806190309273.png">
<meta property="og:image" content="http://example.com/2022/07/22/%5B%E5%A4%87%E5%BF%98%E5%BD%95%5D%5BRust%5D/image-20220806190329332.png">
<meta property="og:image" content="http://example.com/2022/07/22/%5B%E5%A4%87%E5%BF%98%E5%BD%95%5D%5BRust%5D/image-20220807185618825.png">
<meta property="og:image" content="http://example.com/2022/07/22/%5B%E5%A4%87%E5%BF%98%E5%BD%95%5D%5BRust%5D/image-20220815151144403.png">
<meta property="article:published_time" content="2022-07-22T02:45:34.000Z">
<meta property="article:modified_time" content="2022-09-08T13:47:02.594Z">
<meta property="article:author" content="fea01">
<meta property="article:tag" content="学习记录">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/07/22/%5B%E5%A4%87%E5%BF%98%E5%BD%95%5D%5BRust%5D/image-20220727190406930.png">

<link rel="canonical" href="http://example.com/2022/07/22/[%E5%A4%87%E5%BF%98%E5%BD%95][Rust]/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>[备忘录][Rust] | 学海注</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">学海注</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/22/[%E5%A4%87%E5%BF%98%E5%BD%95][Rust]/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="fea01">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学海注">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          [备忘录][Rust]
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-22 10:45:34" itemprop="dateCreated datePublished" datetime="2022-07-22T10:45:34+08:00">2022-07-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-08 21:47:02" itemprop="dateModified" datetime="2022-09-08T21:47:02+08:00">2022-09-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/memorandun/" itemprop="url" rel="index"><span itemprop="name">memorandun</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>Rust 学习曲线陡峭，每次都去查<a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/title-page.html#rust-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">Rust 程序设计语言</a>,有点麻烦，集中记录一些常用的点。</p>
<span id="more"></span>

<h2 id="Cargo-命令"><a href="#Cargo-命令" class="headerlink" title="Cargo 命令"></a>Cargo 命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新建项目</span></span><br><span class="line">cargo new &lt;新项目名&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查错误</span></span><br><span class="line">cargo check</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行项目</span></span><br><span class="line">cargo run</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译项目 debug版</span></span><br><span class="line">cargo build </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译项目 release版</span></span><br><span class="line">cargo build --release</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看文档</span></span><br><span class="line">cargo doc --open</span><br></pre></td></tr></table></figure>



<h2 id="重要特点"><a href="#重要特点" class="headerlink" title="重要特点"></a>重要特点</h2><p><strong>语句</strong>（<em>Statements</em>）是执行一些操作但不返回值的指令。表达式（<em>Expressions</em>）计算并产生一个值。</p>
<p>函数调用是一个表达式。宏调用是一个表达式。用大括号创建的一个新的块作用域也是一个表达式。</p>
<p>函数的返回值等同于函数体最后一个表达式的值。</p>
<p>因为 <code>if</code> 是一个表达式，且Rust是静态强类型，要求编译时知道所有的变量类型，所以不同的分支返回值类型要相同。</p>
<p>loop 也是表达式。<code>break ... ; </code>可以返回值</p>
<p>loop label 语法： ‘xxx ： loop{}</p>
<h2 id="所有权规则"><a href="#所有权规则" class="headerlink" title="所有权规则"></a>所有权规则</h2><p>首先，让我们看一下所有权的规则。当我们通过举例说明时，请谨记这些规则：</p>
<ol>
<li>Rust 中的每一个值都有一个被称为其 <strong>所有者</strong>（<em>owner</em>）的变量。</li>
<li>值在任一时刻有且只有一个所有者。</li>
<li>当所有者（变量）离开作用域，这个值将被丢弃。</li>
</ol>
<p>变量离开作用域后，Rust自动调用<code>Drop</code>函数</p>
<p>如果类型都是已知大小的，可以存储在栈中，并且当离开作用域时被移出栈。如果需要跨作用域使用，则最好将数据存放在堆中。</p>
<h3 id="变量与数据的交互规则：移动-move"><a href="#变量与数据的交互规则：移动-move" class="headerlink" title="变量与数据的交互规则：移动 move"></a>变量与数据的交互规则：移动 move</h3><p>​	浅拷贝，将所有权移交给新变量。将值传递给函数在语义上与给变量赋值相似</p>
<h3 id="变量与数据的交互规则：克隆-clone"><a href="#变量与数据的交互规则：克隆-clone" class="headerlink" title="变量与数据的交互规则：克隆 clone"></a>变量与数据的交互规则：克隆 clone</h3><p>​	深拷贝</p>
<h3 id="只在栈上的数据：拷贝"><a href="#只在栈上的数据：拷贝" class="headerlink" title="只在栈上的数据：拷贝"></a>只在栈上的数据：拷贝</h3><p>​	如果一个类型实现了 <code>Copy</code> trait，那么一个旧的变量在将其赋值给其他变量后仍然可用。Rust 不允许自身或其任何部分实现了 <code>Drop</code> trait 的类型使用 <code>Copy</code> trait。</p>
<ul>
<li>所有整数类型，比如 <code>u32</code>。</li>
<li>布尔类型，<code>bool</code>，它的值是 <code>true</code> 和 <code>false</code>。</li>
<li>所有浮点数类型，比如 <code>f64</code>。</li>
<li>字符类型，<code>char</code>。</li>
<li>元组，当且仅当其包含的类型也都实现 <code>Copy</code> 的时候。比如，<code>(i32, i32)</code> 实现了 <code>Copy</code>，但 <code>(i32, String)</code> 就没有。</li>
</ul>
<h3 id="所有权与函数"><a href="#所有权与函数" class="headerlink" title="所有权与函数"></a>所有权与函数</h3><p>将值传递给函数在语义上与给变量赋值相似。向函数传递值可能会移动或者复制，就像赋值语句一样。</p>
<h3 id="返回值与作用域"><a href="#返回值与作用域" class="headerlink" title="返回值与作用域"></a>返回值与作用域</h3><p>返回值移动给调用它的函数</p>
<p>变量的所有权总是遵循相同的模式：将值赋给另一个变量时移动它。当持有堆中数据值的变量离开作用域时，其值将通过 <code>drop</code> 被清理掉，除非数据被移动为另一个变量所有。</p>
<p>如果我们想要函数使用一个值但不获取所有权该怎么办呢？如果我们还要接着使用它的话，每次都传进去再返回来就有点烦人了，除此之外，我们也可能想返回函数体中产生的一些数据。</p>
<h3 id="引用与借用"><a href="#引用与借用" class="headerlink" title="引用与借用"></a>引用与借用</h3><p><strong>引用</strong>（<em>reference</em>）像一个指针，因为它是一个地址，但是与指针不同，引用确保指向某个特定类型的有效值。</p>
<p>&amp;引用</p>
<p>*解引用</p>
<p>我们将创建一个引用的行为称为 <strong>借用</strong>（<em>borrowing</em>）。</p>
<p>正如变量默认是不可变的，引用也一样。（默认）不允许修改引用的值。</p>
<p>允许我们修改一个借用的值，这就是 <strong>可变引用</strong></p>
<p>可变引用注意点：</p>
<p>不可以同时拥有一个<strong>可变引用</strong>和一个<strong>不可变引用</strong></p>
<p><strong>多个不可变引用</strong>是可以的</p>
<p>在特定的作用域内，对于某一块数据只能有一个可变的引用</p>
<p>可以通过<strong>创建新的作用域</strong>，允许<strong>非同时</strong>地创建多个可变引用</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = String::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r1</span> = &amp;s; <span class="comment">// 没问题</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r2</span> = &amp;s; <span class="comment">// 没问题</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; and &#123;&#125;&quot;</span>, r1, r2);</span><br><span class="line"><span class="comment">// 此位置之后 r1 和 r2 不再使用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r3</span> = &amp;<span class="keyword">mut</span> s; <span class="comment">// 没问题</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, r3);</span><br></pre></td></tr></table></figure>

<p>编译器在作用域结束之前判断不再使用的引用的能力<strong>非词法作用域生命周期</strong>（<em>Non-Lexical Lifetimes</em>，简称 NLL）</p>
<p>悬垂指针是其指向的内存可能已经被分配给其它持有者。相比之下，在 Rust 中编译器确保引用永远也不会变成悬垂状态。当你拥有一些数据的引用，编译器确保数据不会在其引用之前离开作用域。</p>
<p>引用规则：</p>
<ul>
<li>在任意给定时间，<strong>要么</strong> 只能有一个可变引用，<strong>要么</strong> 只能有多个不可变引用。</li>
<li>引用必须总是有效的。</li>
</ul>
<h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p><strong>字符串字面值就是 slice</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br></pre></td></tr></table></figure>

<p>如果有一个 <code>String</code>，则可以传递整个 <code>String</code> 的 slice 或对 <code>String</code> 的引用。这种灵活性利用了 <em>deref coercions</em> 的优势</p>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>struct的整个实例必须是可变的；Rust 并不允许只将某个字段标记为可变。</p>
<p>参数名与字段名都完全相同，我们可以使用 <strong>字段初始化简写语法</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">build_user</span>(email: <span class="type">String</span>, username: <span class="type">String</span>) <span class="punctuation">-&gt;</span> User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        email,</span><br><span class="line">        username,</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>struct 更新语法</strong></p>
<p>..user1 必须放在最后，以指定其余的字段应从 <code>user1</code> 的相应字段中获取其值</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user2</span> = User &#123;</span><br><span class="line">        email: String::<span class="title function_ invoke__">from</span>(<span class="string">&quot;another@example.com&quot;</span>),</span><br><span class="line">        ..user1</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>元组结构体</strong>（<em>tuple structs</em>）</p>
<p>当你想给整个元组取一个名字，并使元组成为与其他元组不同的类型时使用</p>
<p><strong>类单元结构体</strong>（<em>unit-like structs</em>）</p>
<p>类单元结构体常常在你想要在某个类型上实现 trait 但不需要在类型中存储数据的时候发挥作用。？？</p>
<p><strong>Struct 数据的所有权</strong></p>
<p>生命周期确保结构体引用的数据有效性跟结构体本身保持一致。</p>
<p>如果你尝试在结构体中存储一个引用而不指定生命周期将是无效的</p>
<p><strong>整个结构体是有效的话其数据也是有效的</strong></p>
<p>std::fmt::Display</p>
<p>std::fmt::Debug</p>
<p><code>:?</code> 指示符告诉 <code>println!</code> 我们想要使用叫做 <code>Debug</code> 的输出格式。<code>Debug</code> 是一个 trait，它允许我们以一种对开发者有帮助的方式打印结构体</p>
<p>在结构体定义之前加上外部属性 <code>#[derive(Debug)]</code></p>
<p><code>&#123;:#?&#125;</code> 风格</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>它们使用 <code>fn</code> 关键字和名称声明，可以拥有参数和返回值，同时包含在某处调用该方法时会执行的代码。</p>
<p>它们在结构体的上下文中被定义或者是枚举或 trait 对象的上下文</p>
<p>它们第一个参数总是 <code>self</code>它代表调用该方法的结构体实例。</p>
<p><code>&amp;self</code> 实际上是<code> self: &amp;Self</code>的缩写。<code>Self</code> 类型是 <code>impl</code> 块的类型的别名</p>
<p>方法可以选择获得 <code>self</code> 的所有权，或者像我们这里一样不可变地借用 <code>self</code>，或者可变地借用 <code>self</code>，就跟其他参数一样。</p>
<p> <strong>自动引用和解引用</strong>（<em>automatic referencing and dereferencing</em>）的功能。方法调用是 Rust 中少数几个拥有这种行为的地方</p>
<p>Rust 会自动为 <code>object</code> 添加 <code>&amp;</code>、<code>&amp;mut</code> 或 <code>*</code> 以便使 <code>object</code> 与方法签名匹配。</p>
<p>这种自动引用的行为之所以有效，，是因为方法有一个明确的接收者———— <code>self</code> 的类型。在给出接收者和方法名的前提下，Rust 可以明确地计算出方法是仅仅读取（<code>&amp;self</code>），做出修改（<code>&amp;mut self</code>）或者是获取所有权（<code>self</code>）。</p>
<h3 id="关联函数"><a href="#关联函数" class="headerlink" title="关联函数"></a>关联函数</h3><p>不以 <code>self</code> 为第一参数的关联函数（因此不是方法）</p>
<p>:: 关联函数, 也可用于模块创建的命名空间</p>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>枚举允许你通过列举可能的 <strong>成员</strong>（<em>variants</em>） 来定义一个类型。</p>
<p>Rust 的枚举与 F#、OCaml 和 Haskell 这样的函数式编程语言中的 <strong>代数数据类型</strong>（<em>algebraic data types</em>）最为相似。</p>
<p>可以将数据附加到枚举的变体中。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">enum</span> <span class="title class_">IpAddr</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">V4</span>(<span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>),</span><br><span class="line">        <span class="title function_ invoke__">V6</span>(<span class="type">String</span>),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123; x: <span class="type">i32</span>, y: <span class="type">i32</span> &#125;,</span><br><span class="line">    <span class="title function_ invoke__">Write</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">ChangeColor</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">call</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// 在这里定义方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Option&lt;T&gt;</code> 枚举是如此有用以至于它甚至被包含在了 prelude 之中。</p>
<p>可以不需要 <code>Option::</code> 前缀来直接使用 <code>Some</code> 和 <code>None</code></p>
<p>用于描述 一个值要么<strong>有值</strong>要么<strong>没值</strong>，没有NULL（空值）</p>
<h3 id="match-控制流结构"><a href="#match-控制流结构" class="headerlink" title="match 控制流结构"></a>match 控制流结构</h3><p>将一个值与一系列的模式相比较，并根据相匹配的模式执行相应代码。</p>
<p>模式可由字面值、变量、通配符和许多其他内容构成；</p>
<p><code>match</code> 的力量来源于模式的表现力以及编译器检查，它确保了所有可能的情况都得到处理。</p>
<p>match xx {}  是一个表达式</p>
<h4 id="绑定值的匹配"><a href="#绑定值的匹配" class="headerlink" title="绑定值的匹配"></a>绑定值的匹配</h4><p>可以用于匹配option<T></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">plus_one</span>(x: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">       <span class="keyword">match</span> x &#123;</span><br><span class="line">           <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">           <span class="title function_ invoke__">Some</span>(i) =&gt; <span class="title function_ invoke__">Some</span>(i + <span class="number">1</span>),</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">five</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">six</span> = <span class="title function_ invoke__">plus_one</span>(five);</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">none</span> = <span class="title function_ invoke__">plus_one</span>(<span class="literal">None</span>);</span><br></pre></td></tr></table></figure>





<h3 id="if-let简洁控制流"><a href="#if-let简洁控制流" class="headerlink" title="if let简洁控制流"></a>if let简洁控制流</h3><p>处理只匹配一个模式的值而忽略其他模式的情况，语法糖</p>
<h2 id="包-crate和模块"><a href="#包-crate和模块" class="headerlink" title="包 crate和模块"></a>包 crate和模块</h2><p><a target="_blank" rel="noopener" href="https://www.sheshbabu.com/posts/rust-module-system/">Clear explanation of Rust’s module system</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/351091783">Rust模块系统-当main.rs和lib.rs同时存在的坑</a></p>
<p>Rust 中，<code>crate</code> 是一个独立的可编译单元。</p>
<p>具体说来，就是一个或一批文件（如果是一批文件，那么有一个文件是这个 crate 的入口）。它编译后，会对应着生成一个可执行文件或一个库。</p>
<p>包 中至少包含一个crate, 至多一个library crate，任意多个 二进制 crate</p>
<p>crate 默认的入口文件： src&#x2F;main.rs 或者 src&#x2F;lib.rs</p>
<p>通过将文件放在 <em>src&#x2F;bin</em> 目录下，一个包可以拥有多个二进制 crate：每个 <em>src&#x2F;bin</em> 下的文件都会被编译成一个独立的二进制 crate。</p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1899628">Rust中的代码组织:package&#x2F;crate&#x2F;mod</a></p>
<p>Rust 中所有条目（函数，方法，struct，enum，模块，常量）默认私有。</p>
<p>私有模块对同一模块内和下级模块可用。</p>
<p>父级模块无法访问子模块中的私有条目</p>
<p>子模块可以使用所有祖先模块中的条目</p>
<p>如果模块x与main方法在一个.rs文件中，且x处于最外层，main方法可以调用x中的方法。（<strong>根级</strong>）</p>
<p>子模块可以调用父模块中的private函数，但是反过来是不行的.(老爸的钱，就是儿子的钱，但是儿子的钱，除非儿子主动给老爸，否则还是儿子的！)</p>
<p>如果我们在一个结构体定义的前面使用了 <code>pub</code> ，这个结构体会变成公有的，但是这个结构体的字段仍然是私有的</p>
<ul>
<li>use即可以在函数体内，也可以在函数外</li>
<li>当2个模块的函数有重名时，可以用use .. as .. 来取个别名</li>
</ul>
<p>　</p>
<p>module 拆分到多个文件中：</p>
<p><img src="/2022/07/22/%5B%E5%A4%87%E5%BF%98%E5%BD%95%5D%5BRust%5D/image-20220727190406930.png" alt="image-20220727190406930"></p>
<p>与常规mod不同的是，mod x后，并没有{…}代码块，而是;号，rust会在同级目录下，默认去找x.rs，再来看main方法：</p>
<p>使用 <code>mod &lt;路径&gt;</code> 语法，将一个 rust 源码文件作为模块内引入：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> a;</span><br></pre></td></tr></table></figure>



<h3 id="pub-struct"><a href="#pub-struct" class="headerlink" title="pub struct"></a>pub struct</h3><p>结构体会变成公有的，但是这个结构体的字段仍然是私有的</p>
<p><code>back_of_house::Breakfast</code> 具有私有字段，所以这个结构体需要提供一个公共的关联函数来构造 <code>Breakfast</code> 的实例</p>
<h3 id="pub-enum"><a href="#pub-enum" class="headerlink" title="pub enum"></a>pub enum</h3><p>如果我们将枚举设为公有，则它的所有成员都将变为公有。</p>
<h3 id="use"><a href="#use" class="headerlink" title="use"></a>use</h3><p>函数引入到父级模块</p>
<p>其他直接引入到本身</p>
<p>同名条目，指定到父级</p>
<h3 id="as"><a href="#as" class="headerlink" title="as"></a>as</h3><p>使用 <code>as</code> 关键字提供新的名称</p>
<h3 id="pub-use"><a href="#pub-use" class="headerlink" title="pub use"></a>pub use</h3><p><em>重导出</em>（<em>re-exporting</em>）</p>
<p>使用 <code>use</code> 关键字，将某个名称导入当前作用域后，这个名称在此作用域中就可以使用了，但它对此作用域之外还是私有的。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> crate::front_of_house::hosting;</span><br></pre></td></tr></table></figure>

<p>我们不仅将一个名称导入了当前作用域，还允许别人把它导入他们自己的作用域。</p>
<h3 id="使用外部包"><a href="#使用外部包" class="headerlink" title="使用外部包"></a>使用外部包</h3><ul>
<li>添加依赖和版本</li>
<li>use 将特定条目引入作用域</li>
</ul>
<p><strong>P31 3:00 之后</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --snip--</span></span><br><span class="line"><span class="keyword">use</span> std::cmp::Ordering;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::&#123;cmp::Ordering, io&#125;;</span><br><span class="line"><span class="comment">// _____________________________</span></span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Write;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Write&#125;;</span><br><span class="line"><span class="comment">// *glob 运算符 引用全部，用于test </span></span><br><span class="line"><span class="keyword">use</span> std::collections::*;</span><br></pre></td></tr></table></figure>

<h3 id="拆分模块为多个文件"><a href="#拆分模块为多个文件" class="headerlink" title="拆分模块为多个文件"></a>拆分模块为多个文件</h3><p>在 <code>mod front_of_house</code> 后使用分号，而不是代码块，这将告诉 Rust 在另一个与模块同名的文件中加载模块的内容。</p>
<p>创建一个 <em>src&#x2F;front_of_house</em> <strong>目录</strong>和一个<strong>包含</strong> <code>hosting</code> 模块定义的 <em>src&#x2F;front_of_house&#x2F;hosting.rs</em></p>
<h2 id="常用集合"><a href="#常用集合" class="headerlink" title="常用集合"></a>常用集合</h2><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>vector 允许我们在一个单独的数据结构中储存多于一个的值，它在内存中彼此相邻地排列所有的值。vector 只能储存相同类型的值。</p>
<p>不能同时存在可变的借用和不可变的借用</p>
<p>vector + enum 可以存放多种类型的数据，提前知晓多种数据的长度，便于堆内存分配。</p>
<p>对于不确定的类型，可以使用trait对象</p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p><img src="/2022/07/22/%5B%E5%A4%87%E5%BF%98%E5%BD%95%5D%5BRust%5D/image-20220728124705531.png" alt="image-20220728124705531"></p>
<p>+拼接字符串，类似</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">add</span>(<span class="keyword">self</span>,s:&amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span><span class="title function_ invoke__">String</span>()</span><br></pre></td></tr></table></figure>

<p>解引用强制转换 &amp;String -&gt; &amp;str</p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>哈希 map 是同质的：所有的键必须是相同类型，值也必须都是相同类型。</p>
<p>如果将值的引用插入哈希 map，这些值本身将不会被移动进哈希 map。这些引用指向的值必须至少在哈希 map 有效时也是有效的。</p>
<p> <code>or_insert</code> 方法在键对应的值存在时就返回这个值的可变引用，如果不存在则将参数作为新值插入并返回新值的可变引用。</p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>set <code>RUST_BACKTRACE</code>  &#x3D; 1环境变量来得到一个 backtrace</p>
<p>为了获取带有这些信息的 backtrace，必须启用 debug 标识。当不使用 <code>--release</code> 参数运行 cargo build</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">	<span class="title function_ invoke__">Ok</span>(T),    </span><br><span class="line">	<span class="title function_ invoke__">Err</span>(E), </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>T</code> 和 <code>E</code> 是泛型类型参数；第十章会详细介绍泛型。现在你需要知道的就是 <code>T</code> 代表成功时返回的 <code>Ok</code> 成员中的数据的类型，而 <code>E</code> 代表失败时返回的 <code>Err</code> 成员中的错误的类型。</p>
<p>失败时 panic 的简写：<code>unwrap</code> 和 <code>expect</code></p>
<h3 id="错误传播"><a href="#错误传播" class="headerlink" title="错误传播"></a>错误传播</h3><p>当编写一个其实先会调用一些可能会失败的操作的函数时，除了在这个函数中处理错误外，还可以选择让调用者知道这个错误并决定该如何处理。</p>
<p>结尾的 <code>?</code> 将会把 <code>Ok</code> 中的值返回给变量 <code>f</code>。如果出现了错误，<code>?</code> 运算符会提早返回整个函数并将一些 <code>Err</code> 值传播给调用者。</p>
<p>函数的返回值必须是 <code>Result</code> 才能与这个 <code>return</code> 相兼容。</p>
<p>验证逻辑写进构造函数</p>
<h2 id="泛型-trait-和-生命周期"><a href="#泛型-trait-和-生命周期" class="headerlink" title="泛型 trait 和 生命周期"></a>泛型 trait 和 生命周期</h2><p><strong>泛型</strong>是具体类型或其他属性的抽象替代。我们可以表达泛型的属性，比如他们的行为或如何与其他泛型相关联</p>
<p><strong>trait</strong>，这是一个定义泛型行为的方法。trait 可以与泛型结合来将泛型限制为拥有特定行为的类型，而不是任意类型。</p>
<p> <strong>生命周期</strong>（<em>lifetimes</em>），它是一类允许我们向编译器提供引用如何相互关联的泛型。Rust 的生命周期功能允许在很多场景下借用值的同时仍然使编译器能够检查这些引用的有效性。</p>
<p>Rust 类型名的命名规范是骆驼命名法（CamelCase）</p>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>你可以在定义中使用任意多的泛型类型参数，不过太多的话，代码将难以阅读和理解。当你的代码中需要许多泛型类型时，它可能表明你的代码需要重构，分解成更小的结构。</p>
<p>可以在<strong>函数</strong>，<strong>结构体</strong>，<strong>枚举</strong>，<strong>方法</strong>中使用泛型</p>
<p>注意必须在 <code>impl</code> 后面声明 <code>T</code>，这样就可以在 <code>Point&lt;T&gt;</code> 上实现的方法中使用它了</p>
<p>定义方法适用于某些有限制（constraint）的泛型类型。例如，可以选择为 <code>Point&lt;f32&gt;</code> 实例实现方法，而不是为泛型 <code>Point</code> 实例。</p>
<p>Rust 通过在编译时进行泛型代码的 <strong>单态化</strong>（<em>monomorphization</em>）来保证效率。</p>
<h3 id="tarit"><a href="#tarit" class="headerlink" title="tarit"></a>tarit</h3><p><em>trait</em> 告诉 Rust 编译器某个特定类型拥有可能与其他类型共享的功能。可以通过 trait 以一种抽象的方式定义共享的行为。</p>
<p>可以使用 <em>trait bounds</em> 指定泛型是任何拥有特定行为的类型。</p>
<p>只有当至少一个 trait 或者要实现 trait 的类型位于 crate 的本地作用域时，才能为该类型实现 trait。</p>
<p>不能为外部类型实现外部 trait</p>
<p>这个限制是被称为 <strong>相干性</strong>（<em>coherence</em>） 的程序属性的一部分，或者更具体的说是 <strong>孤儿规则</strong>（<em>orphan rule</em>），其得名于不存在父类型。这条规则确保了其他人编写的代码不会破坏你代码</p>
<p><strong>默认实现</strong></p>
<p>无法从相同方法的重载实现中调用默认方法</p>
<h4 id="trait-作为参数"><a href="#trait-作为参数" class="headerlink" title="trait 作为参数"></a>trait 作为参数</h4><p>该参数是实现了 <code>Summary</code> trait 的某种类型。</p>
<h4 id="返回实现了-trait-的类型"><a href="#返回实现了-trait-的类型" class="headerlink" title="返回实现了 trait 的类型"></a>返回实现了 trait 的类型</h4><p>这里尝试返回 <code>NewsArticle</code> 或 <code>Tweet</code>。这不能编译，因为 <code>impl Trait</code> 工作方式的限制。</p>
<p>函数返回值类型不能 不同</p>
<h4 id="使用-trait-bound-有条件地实现方法"><a href="#使用-trait-bound-有条件地实现方法" class="headerlink" title="使用 trait bound 有条件地实现方法"></a>使用 trait bound 有条件地实现方法</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Pair&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(x: T, y: T) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123; x, y &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: Display + <span class="built_in">PartialOrd</span>&gt; Pair&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">cmp_display</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.x &gt;= <span class="keyword">self</span>.y &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;The largest member is x = &#123;&#125;&quot;</span>, <span class="keyword">self</span>.x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;The largest member is y = &#123;&#125;&quot;</span>, <span class="keyword">self</span>.y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只有实现了  Display + PartialOrd 这两个trait 的 类型 T 才具有 cmp_display 方法</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: Display&gt; <span class="built_in">ToString</span> <span class="keyword">for</span> <span class="title class_">T</span> &#123;    <span class="comment">// --snip-- </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为所有实现了 Display 这个 trait 的 类型 T 实现 ToString 这个trait</p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>生命周期则有助于确保<strong>引用</strong>在我们需要他们的时候一直有效。</p>
<p>避免悬垂引用</p>
<p>记住通过在函数签名中指定生命周期参数时，我们并没有改变任何传入值或返回值的生命周期，而是指出任何不满足这个约束条件的值都将被借用检查器拒绝。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;<span class="comment">// --snip-- </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>被 <code>&#39;a</code> 所替代的具体生命周期是 <code>x</code> 的作用域与 <code>y</code> 的作用域相重叠的那一部分。换一种说法就是泛型生命周期 <code>&#39;a</code> 的具体生命周期等同于 <code>x</code> 和 <code>y</code> 的生命周期中较小的那一个。</p>
<p><strong>生命周期省略</strong>规则：</p>
<ul>
<li>第一条规则是每一个是引用的参数都有它自己的生命周期参数。</li>
<li>第二条规则是如果只有一个输入生命周期参数，那么它被赋予所有输出生命周期参数</li>
<li>第三条规则是如果方法有多个输入生命周期参数并且其中一个参数是 <code>&amp;self</code> 或 <code>&amp;mut self</code>，说明是个对象的方法(method), 那么所有输出生命周期参数被赋予 <code>self</code> 的生命周期。</li>
</ul>
<h3 id="方法定义中的生命周期注解"><a href="#方法定义中的生命周期注解" class="headerlink" title="方法定义中的生命周期注解"></a>方法定义中的生命周期注解</h3><p><code>&#39;static</code>，其生命周期<strong>能够</strong>存活于整个程序期间</p>
<h2 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h2><p><strong>#[test]</strong> 属性添加在测试函数前,不发生panic 通过</p>
<p>use super::* 导入测试的模块</p>
<p>assert!(bool, msg, …)</p>
<p>assert_eq!(a,b,msg,…)</p>
<p>assert_ne!(a,b,msg,…)  msg可以使用{}</p>
<p><strong>#[should_panic]</strong>  发生panic 通过</p>
<p>针对<code>Result&lt;T,E&gt;</code> 测试. 不能对这些使用 <code>Result&lt;T, E&gt;</code> 的测试使用 <code>#[should_panic]</code> 注解。</p>
<p><strong>不要</strong>使用对 <code>Result&lt;T, E&gt;</code> 值使用问号表达式（<code>?</code>）,而是使用 <code>assert!(value.is_err())</code></p>
<p> Rust 默认使用线程来并行运行。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo test -- --test-threads=1</span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo test -- --show-output</span><br></pre></td></tr></table></figure>

<p><code>--show-output</code> 告诉 Rust 显示成功测试的输出。</p>
<p>可以向 <code>cargo test</code> 传递任意测试的名称来只运行这个测试。</p>
<p>我们可以指定部分测试的名称，任何名称匹配这个名称的测试会被运行。</p>
<p>#[ignore] 忽略测试函数</p>
<p>当你需要运行 <code>ignored</code> 的测试时，可以执行 <code>cargo test -- --ignored</code>。如果你希望不管是否忽略都要运行全部测试，可以运行 <code>cargo test -- --include-ignored</code>。</p>
<h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>单元测试的目的是在与其他部分隔离的环境中测试每一个单元的代码，以便于快速而准确的某个单元的代码功能是否符合预期。</p>
<p>单元测试与他们要测试的代码共同存放在位于 <em>src</em> 目录下相同的文件中。规范是在每个文件中创建包含测试函数的 <code>tests</code> 模块，并使用 <code>cfg(test)</code> 标注模块， 注解告诉 Rust 只在执行 <code>cargo test</code> 时才编译和运行测试代码</p>
<p>Rust 的私有性规则确实允许你测试私有函数。</p>
<h3 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h3><p>需要在项目根目录创建一个 <em>tests</em> 目录，与 <em>src</em> 同级。</p>
<p>接着可以随意在这个目录中创建任意多的测试文件，Cargo 会将每一个文件当作单独的 crate 来编译。</p>
<p>文件名: tests&#x2F;integration_test.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> adder; <span class="comment">// 被测试的lib crate</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">it_adds_two</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">4</span>, adder::<span class="title function_ invoke__">add_two</span>(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过指定测试函数的名称作为 <code>cargo test</code> 的参数来运行特定集成测试。也可以使用 <code>cargo test</code> 的 <code>--test</code> 后跟文件的名称来运行某个特定集成测试文件中的所有测试</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo test --test integration_test</span><br></pre></td></tr></table></figure>



<h4 id="二进制-crate-的集成测试"><a href="#二进制-crate-的集成测试" class="headerlink" title="二进制 crate 的集成测试"></a>二进制 crate 的集成测试</h4><p>只有库 crate 才会向其他 crate 暴露了可供调用和使用的函数；二进制 crate 只意在单独运行</p>
<p>Rust 二进制项目的结构明确采用 <em>src&#x2F;main.rs</em> 调用 <em>src&#x2F;lib.rs</em> 中的逻辑的方式<strong>就可以</strong> 通过 <code>extern crate</code> 测试库 crate 中的主要功能</p>
<h2 id="项目CLI"><a href="#项目CLI" class="headerlink" title="项目CLI"></a>项目CLI</h2><p>对 <code>mod</code> 和 <code>use</code> 进行区分：**<code>use</code> 仅仅是在存在模块的前提下，调整调用路径，而没有引入模块的功能，引入模块使用 <code>mod</code>**</p>
<h2 id="函数式编程，迭代器与闭包"><a href="#函数式编程，迭代器与闭包" class="headerlink" title="函数式编程，迭代器与闭包"></a>函数式编程，迭代器与闭包</h2><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>Rust 的 <strong>闭包</strong>（<em>closures</em>）是可以保存在一个变量中或作为参数传递给其他函数的匿名函数。可以在一个地方创建闭包，然后在不同的上下文中执行闭包运算。不同于函数，闭包允许捕获调用者作用域中的值。</p>
<p>闭包不要求像 <code>fn</code> 函数那样在参数和返回值上注明类型。函数中需要类型注解是因为他们是暴露给用户的显式接口的一部分。严格的定义这些接口对于保证所有人都认同函数使用和返回值的类型来说是很重要的。但是闭包并不用于这样暴露在外的接口：他们储存在变量中并被使用，<strong>不用命名他们或暴露给库的用户调用</strong>。</p>
<p>如果相比严格的必要性你更希望增加明确性并变得更啰嗦，可以选择增加类型注解</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">expensive_closure</span> = |num: <span class="type">u32</span>| <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;calculating slowly...&quot;</span>);</span><br><span class="line">    thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">2</span>));</span><br><span class="line">    num</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用竖线而不是括号以及几个<strong>可选的语法</strong>之外：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span>  <span class="title function_">add_one_v1</span>   (x: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123; x + <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">add_one_v2</span> = |x: <span class="type">u32</span>| <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123; x + <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">add_one_v3</span> = |x|             &#123; x + <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">add_one_v4</span> = |x|               x + <span class="number">1</span>  ;</span><br></pre></td></tr></table></figure>

<p>如果尝试对同一闭包使用不同类型则会得到类型错误</p>
<p><em>memoization</em> 或 <em>lazy evaluation</em> <em>（惰性求值）</em></p>
<p>为了让结构体存放闭包，我们需要指定闭包的类型，因为结构体定义需要知道其每一个字段的类型。</p>
<p>每一个闭包实例有其自己独有的匿名类型：也就是说，即便两个闭包有着<strong>相同的签名</strong>，他们的类型仍然可以<strong>被认为是不同</strong>。</p>
<p><code>Fn</code> 系列 trait 由标准库提供。所有的闭包都实现了 trait <code>Fn</code>、<code>FnMut</code> 或 <code>FnOnce</code> 中的一个。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/dream397/p/14190206.html">闭包是什么？</a></p>
<ul>
<li><code>FnOnce</code> 消费从周围作用域捕获的变量，闭包周围的作用域被称为其 <strong>环境</strong>，<em>environment</em>。为了消费捕获到的变量，闭包必须<strong>获取其所有权</strong>并在定义闭包时将其移动进闭包。其名称的 <code>Once</code> 部分代表了闭包不能多次获取相同变量的所有权的事实，所以它只能被调用一次。</li>
<li><code>FnMut</code> <strong>获取可变的借用值</strong>所以可以改变其环境</li>
<li><code>Fn</code> 从其环境<strong>获取不可变的借用值</strong></li>
</ul>
<p><strong>move 关键字</strong></p>
<p><code>x</code> 被移动进了闭包，因为闭包使用 <code>move</code> 关键字定义。接着闭包获取了 <code>x</code> 的所有权，同时 <code>main</code> 就不再允许在 <code>println!</code> 语句中使用 <code>x</code> 了。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">equal_to_x</span> = <span class="keyword">move</span> |z| z == x;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;can&#x27;t use x here: &#123;:?&#125;&quot;</span>, x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert!</span>(<span class="title function_ invoke__">equal_to_x</span>(y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>大部分需要指定一个 <code>Fn</code> 系列 trait bound 的时候，可以从 <code>Fn</code> 开始，而编译器会根据闭包体中的情况告诉你是否需要 <code>FnMut</code> 或 <code>FnOnce</code>。</p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p><strong>迭代器</strong>（<em>iterator</em>）负责遍历序列中的每一项和决定序列何时结束的逻辑。</p>
<p>迭代器都实现了一个叫做 <code>Iterator</code> 的定义于标准库的 trait</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略了方法的默认实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>type Item</code> 和 <code>Self::Item</code>，他们定义了 trait 的 <strong>关联类型</strong></p>
<p><code>next</code> 是 <code>Iterator</code> 实现者被要求定义的唯一方法。<code>next</code> 一次返回迭代器中的一个项，封装在 <code>Some</code> 中，当迭代器结束时，它返回 <code>None</code>。</p>
<p>在迭代器上调用 <code>next</code> 方法改变了迭代器中用来记录序列位置的状态。代码 <strong>消费</strong>（consume）了，或使用了迭代器。</p>
<p><code>for</code> 循环时无需使 <code>v1_iter</code> 可变因为 <code>for</code> 循环会获取 <code>v1_iter</code> 的所有权并在后台使 <code>v1_iter</code> 可变。</p>
<p>调用 <code>next</code> 方法的方法被称为 <strong>消费适配器</strong>（<em>consuming adaptors</em>），因为调用他们会消耗迭代器</p>
<p><code>iter</code> 方法生成一个不可变引用的迭代器。</p>
<p>如果我们需要一个获取 <code>v1</code> 所有权并返回拥有所有权的迭代器，则可以调用 <code>into_iter</code> 。</p>
<p>如果我们希望迭代可变引用，则可以调用 <code>iter_mut</code> 。</p>
<h4 id="产生其他迭代器的方法"><a href="#产生其他迭代器的方法" class="headerlink" title="产生其他迭代器的方法"></a>产生其他迭代器的方法</h4><p><code>Iterator</code> trait 中定义了另一类方法，被称为 <strong>迭代器适配器</strong>（<em>iterator adaptors</em>），他们允许我们将当前迭代器变为不同类型的迭代器。可以链式调用多个迭代器适配器。</p>
<p>不过因为所有的迭代器都是惰性的，必须调用一个消费适配器方法以便获取迭代器适配器调用的结果。</p>
<p><code>map</code> 方法使用闭包来调用每个元素以生成新的迭代器。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v2</span>: <span class="type">Vec</span>&lt;_&gt; = v1.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">map</span>(|x| x + <span class="number">1</span>).<span class="title function_ invoke__">collect</span>();</span><br></pre></td></tr></table></figure>



<p><code>filter</code> 方法获取一个使用迭代器的每一个项并返回布尔值的闭包。如果闭包返回 <code>true</code>，其值将会包含在 <code>filter</code> 提供的新迭代器中。如果闭包返回 <code>false</code>，其值不会包含在结果迭代器中。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">shoes_in_size</span>(shoes: <span class="type">Vec</span>&lt;Shoe&gt;, shoe_size: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;Shoe&gt; &#123;</span><br><span class="line">    shoes.<span class="title function_ invoke__">into_iter</span>().<span class="title function_ invoke__">filter</span>(|s| s.size == shoe_size).<span class="title function_ invoke__">collect</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>闭包<strong>从环境中捕获</strong>了 <code>shoe_size</code> 变量并使用其值与每一只鞋的大小作比较，只保留指定大小的鞋子。最终，调用 <code>collect</code> 将迭代器适配器返回的值收集进一个 vector 并返回。</p>
<h4 id="实现-Iterator-trait-来创建自定义迭代器"><a href="#实现-Iterator-trait-来创建自定义迭代器" class="headerlink" title="实现 Iterator trait 来创建自定义迭代器"></a>实现 <code>Iterator</code> trait 来创建自定义迭代器</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">using_other_iterator_trait_methods</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">sum</span>: <span class="type">u32</span> = Counter::<span class="title function_ invoke__">new</span>()</span><br><span class="line">            .<span class="title function_ invoke__">zip</span>(Counter::<span class="title function_ invoke__">new</span>().<span class="title function_ invoke__">skip</span>(<span class="number">1</span>))</span><br><span class="line">            .<span class="title function_ invoke__">map</span>(|(a, b)| a * b)</span><br><span class="line">            .<span class="title function_ invoke__">filter</span>(|x| x % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">            .<span class="title function_ invoke__">sum</span>();</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="number">18</span>, sum);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>zip 将两个迭代器，返回新的迭代器，新的迭代器返回一个元组，其中的值为输入的两个迭代器产生的序列中对应的值</p>
<h2 id="cargo-与-crate-is"><a href="#cargo-与-crate-is" class="headerlink" title="cargo 与 crate.is"></a>cargo 与 crate.is</h2><p><strong>发布配置</strong>（<em>release profiles</em>）是预定义的、可定制的带有不同选项的配置。每一个配置都彼此<strong>相互独立</strong>。</p>
<p>Cargo 有两个主要的配置：<code>dev</code> 配置、<code>release</code> 配置</p>
<p>通过增加任何希望定制的配置对应的 <code>[profile.*]</code> 部分，我们可以选择覆盖任意默认设置的子集。</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[profile.dev]</span></span><br><span class="line"><span class="attr">opt-level</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="section">[profile.release]</span></span><br><span class="line"><span class="attr">opt-level</span> = <span class="number">3</span></span><br></pre></td></tr></table></figure>



<p>文档注释使用三斜杠 <code>///</code> 而不是两斜杆以支持 Markdown 注解来格式化文本。</p>
<p> <code># Examples</code> Markdown 标题在 HTML 中创建了一个以 “Examples” 为标题的部分。其他一些 crate 作者经常在文档注释中使用的部分有：</p>
<ul>
<li><strong>Panics</strong>：这个函数可能会 <code>panic!</code> 的场景。并不希望程序崩溃的函数调用者应该确保他们不会在这些情况下调用此函数。</li>
<li><strong>Errors</strong>：如果这个函数返回 <code>Result</code>，此部分描述可能会出现何种错误以及什么情况会造成这些错误，这有助于调用者编写代码来采用不同的方式处理不同的错误。</li>
<li><strong>Safety</strong>：如果这个函数使用 <code>unsafe</code> 代码（这会在第十九章讨论），这一部分应该会涉及到期望函数调用者支持的确保 <code>unsafe</code> 块中代码正常工作的不变条件（invariants）。</li>
</ul>
<p>Rust 也有特定的用于文档的注释类型，通常被称为 <strong>文档注释</strong></p>
<p>文档注释，<code>//!</code>，这为包含注释的项，而不是位于注释之后的项增加文档。</p>
<h3 id="pub-use-1"><a href="#pub-use-1" class="headerlink" title="pub use"></a>pub use</h3><p>你可以选择使用 <code>pub use</code> 重导出（re-export）项来使公有结构不同于私有结构。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! # Art</span></span><br><span class="line"><span class="comment">//!</span></span><br><span class="line"><span class="comment">//! A library for modeling artistic concepts.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> self::kinds::PrimaryColor;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> self::kinds::SecondaryColor;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> self::utils::mix;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> kinds &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    <span class="comment">/// The primary colors according to the RYB color model.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">PrimaryColor</span> &#123;</span><br><span class="line">        Red,</span><br><span class="line">        Yellow,</span><br><span class="line">        Blue,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// The secondary colors according to the RYB color model.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">SecondaryColor</span> &#123;</span><br><span class="line">        Orange,</span><br><span class="line">        Green,</span><br><span class="line">        Purple,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> utils &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    <span class="keyword">use</span> crate::kinds::*;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Combines two primary colors in equal amounts to create</span></span><br><span class="line">    <span class="comment">/// a secondary color.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">mix</span>(c1: PrimaryColor, c2: PrimaryColor) <span class="punctuation">-&gt;</span> SecondaryColor &#123;</span><br><span class="line">        SecondaryColor::Orange</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> art::mix;</span><br><span class="line"><span class="keyword">use</span> art::PrimaryColor;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缩短使用者的路径</p>
<h3 id="发布到-Crates-io"><a href="#发布到-Crates-io" class="headerlink" title="发布到 Crates.io"></a>发布到 Crates.io</h3><p>发布 crate 时请多加小心，因为发布是 <strong>永久性的</strong>（<em>permanent</em>）。对应版本不可能被覆盖，其代码也不可能被删除。<a target="_blank" rel="noopener" href="https://crates.io/">crates.io</a> 的一个主要目标是作为一个存储代码的永久文档服务器，这样所有依赖 <a target="_blank" rel="noopener" href="https://crates.io/">crates.io</a> 中的 crate 的项目都能一直正常工作。</p>
<p>license 和 description 字段 必需</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo publish</span><br></pre></td></tr></table></figure>



<p>虽然你不能删除之前版本的 crate，但是可以阻止任何将来的项目将他们加入到依赖中。这在某个版本因为这样或那样的原因被破坏的情况很有用。对于这种情况，Cargo 支持 <strong>撤回</strong>（<em>yanking</em>）某个版本。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo yank --vers 1.0.1</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo yank --vers 1.0.1 --undo</span></span><br></pre></td></tr></table></figure>



<h3 id="工作空间"><a href="#工作空间" class="headerlink" title="工作空间"></a>工作空间</h3><p><strong>工作空间</strong> 是一系列共享同样的 <em>Cargo.lock</em> 和输出目录的包。</p>
<p><em>Cargo.toml</em> 它以 <code>[workspace]</code> 部分作为开始，并通过指定 <em>adder</em> 的路径来为工作空间增加成员</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[workspace]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">members</span> = [</span><br><span class="line">    <span class="string">&quot;adder&quot;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<p>通过共享一个 <em>target</em> 目录，工作空间可以避免其他 crate 多余的重复构建。</p>
<p>为了在顶层 <em>add</em> 目录运行二进制 crate，可以通过 <code>-p</code> 参数和包名称来运行 <code>cargo run</code> 指定工作空间中我们希望使用的包：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo run -p adder</span><br></pre></td></tr></table></figure>



<p>工作空间只在根目录有一个 <em>Cargo.lock</em></p>
<p>使得工作空间中的所有 crate 都使用相同的依赖意味着其中的 crate 都是相互兼容的。</p>
<p>每个crate 需要独立写各自的cargo.toml,以此确定依赖</p>
<p>工作空间中的测试，如果在顶级目录cargo test，则运行所有crate 的测试。可以 -p 指定具体的 crate</p>
<p>发布工作空间中的 crate，每一个工作空间中的 crate 需要单独发布。</p>
<h3 id="从crate-io-安装二进制crate"><a href="#从crate-io-安装二进制crate" class="headerlink" title="从crate.io 安装二进制crate"></a>从crate.io 安装二进制crate</h3><p>cargo install</p>
<p><strong>二进制目标</strong> 文件是在 crate 有 <em>src&#x2F;main.rs</em> 或者其他指定为二进制文件时所创建的可执行程序</p>
<p>默认安装目录是 <code>$HOME/.cargo/bin</code>，确保将这个目录添加到 <code>$PATH</code> 环境变量中就能够运行通过 <code>cargo install</code> 安装的程序了</p>
<h3 id="自定义命令扩展cargo"><a href="#自定义命令扩展cargo" class="headerlink" title="自定义命令扩展cargo"></a>自定义命令扩展cargo</h3><p>如果 <code>$PATH</code> 中有类似 <code>cargo-something</code> 的二进制文件，就可以通过 <code>cargo something</code> 来像 Cargo 子命令一样运行它。</p>
<p>运行 <code>cargo --list</code> 来展示出来</p>
<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p><strong>指针</strong> （<em>pointer</em>）是一个包含内存地址的变量的通用概念。</p>
<p>这个地址引用，或 “指向”（points at）一些其他数据。</p>
<p>Rust 中最常见的指针是第四章介绍的 <strong>引用</strong>（<em>reference</em>）。引用以 <code>&amp;</code> 符号为标志并借用了他们所指向的值。除了引用数据没有任何其他特殊功能。它们也没有任何额外开销，所以应用得最多。</p>
<p><strong>智能指针</strong>（<em>smart pointers</em>）是一类数据结构，他们的表现类似指针，但是也<strong>拥有额外的元数据和功能</strong>。</p>
<p>引用是一类只借用数据的指针；在大部分情况下，智能指针 <strong>拥有</strong> 他们指向的数据。</p>
<p>智能指针通常使用结构体实现。智能指针区别于常规结构体的显著特性在于其实现了 <code>Deref</code> 和 <code>Drop</code> trait。</p>
<p><code>Deref</code> trait 允许智能指针结构体实例表现的像引用一样，这样就可以编写既用于引用、又用于智能指针的代码。<code>Drop</code> trait 允许我们自定义当智能指针离开作用域时运行的代码。</p>
<h3 id="使用Box-指向堆上的数据"><a href="#使用Box-指向堆上的数据" class="headerlink" title="使用Box 指向堆上的数据"></a>使用<code>Box </code>指向堆上的数据</h3><p>最简单直接的智能指针是 <em>box</em>，其类型是 <code>Box&lt;T&gt;</code>, box 允许你将一个值放在堆上而不是栈上。留在栈上的则是指向堆数据的指针。</p>
<ul>
<li><p>当有一个在编译时未知大小的类型，而又想要在需要确切大小的上下文中使用这个类型值的时候</p>
<p>存放在栈上的指针是大小确定的</p>
</li>
<li><p>当有大量数据并希望在确保数据不被拷贝的情况下转移所有权的时候</p>
<p>同上，通过只有少量的指针数据在栈上被拷贝，避免大量的数据传输</p>
</li>
<li><p>当希望拥有一个值并只关心它的类型是否实现了特定 trait 而不是其具体类型的时候</p>
</li>
</ul>
<p>​		<strong>trait 对象</strong>（<em>trait object</em>）</p>
<h4 id="Box-允许创建递归类型"><a href="#Box-允许创建递归类型" class="headerlink" title="Box 允许创建递归类型"></a>Box 允许创建递归类型</h4><p>代表递归的终止条件（base case）的规范名称是 <code>Nil</code>，它宣布列表的终止。注意这不同于第六章中的 “null” 或 “nil” 的概念，他们代表无效或缺失的值。</p>
<p><em>cons list</em> 是一个来源于 Lisp 编程语言及其方言的数据结构。</p>
<p>cons list 的每一项都包含两个元素：当前项的值和下一项。</p>
<p>其最后一项值包含一个叫做 <code>Nil</code> 的值且没有下一项。cons list 通过递归调用 <code>cons</code> 函数产生。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, <span class="type">Box</span>&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="通过-Deref-trait-将智能指针当作常规引用处理"><a href="#通过-Deref-trait-将智能指针当作常规引用处理" class="headerlink" title="通过 Deref trait 将智能指针当作常规引用处理"></a>通过 Deref trait 将智能指针当作常规引用处理</h3><p>实现 <code>Deref</code> trait 允许我们重载 <strong>解引用运算符</strong></p>
<p>从根本上说，<code>Box&lt;T&gt;</code> 被定义为包含一个元素的元组结构体</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyBox</span>&lt;T&gt;(T);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(x: T) <span class="punctuation">-&gt;</span> MyBox&lt;T&gt; &#123;</span><br><span class="line">        <span class="title function_ invoke__">MyBox</span>(x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p> <code>*y</code> ，Rust 事实上在底层运行了如下代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*(y.<span class="title function_ invoke__">deref</span>())</span><br></pre></td></tr></table></figure>

<p>每次当我们在代码中使用 <code>*</code> 时， <code>*</code> 运算符都被替换成了先调用 <code>deref</code> 方法再接着使用 <code>*</code> 解引用的操作，且只会发生一次，不会对 <code>*</code> 操作符无限递归替换</p>
<h4 id="函数和方法的隐式-Deref-强制转换"><a href="#函数和方法的隐式-Deref-强制转换" class="headerlink" title="函数和方法的隐式 Deref 强制转换"></a>函数和方法的隐式 Deref 强制转换</h4><p><strong>Deref 强制转换</strong>（<em>deref coercions</em>）是 Rust 在函数或方法传参上的一种便利</p>
<p>Deref 强制转换只能作用于实现了 <code>Deref</code> trait 的类型。Deref 强制转换将这样一个类型的引用转换为另一个类型的引用。</p>
<p>当这种特定类型的引用作为实参传递给和形参类型不同的函数或方法时，Deref 强制转换将自动发生。这时会有<strong>一系列</strong>的 <code>deref</code> 方法被调用，把我们提供的类型转换成了参数所需的类型。</p>
<p>这些解析都发生在编译时，所以利用 Deref 强制转换并没有运行时损耗</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Deref;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyBox</span>&lt;T&gt;(T);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(x: T) <span class="punctuation">-&gt;</span> MyBox&lt;T&gt; &#123;</span><br><span class="line">        <span class="title function_ invoke__">MyBox</span>(x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> <span class="title class_">MyBox</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Target &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">hello</span>(name: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, &#123;&#125;!&quot;</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m</span> = MyBox::<span class="title function_ invoke__">new</span>(String::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Rust&quot;</span>));</span><br><span class="line">    <span class="comment">// &amp;m : &amp;MyBox&lt;String&gt; 由于实现了 deref</span></span><br><span class="line">    <span class="comment">// --&gt;  &amp;String     标准库中String也实现了deref</span></span><br><span class="line">    <span class="comment">// --&gt;  &amp;str        &amp;str 满足hello函数的调用需求 </span></span><br><span class="line">    <span class="title function_ invoke__">hello</span>(&amp;m);</span><br><span class="line">    <span class="title function_ invoke__">hello</span>(&amp;(*m)[..]); <span class="comment">// 如果没有隐式类型强制转换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>Deref</code> trait 重载<strong>不可变引用</strong>的 <code>*</code> 运算符</p>
<p> <code>DerefMut</code> trait 用于重载<strong>可变引用</strong>的 <code>*</code> 运算符</p>
<p>Rust 在发现类型和 trait 实现满足三种情况时会进行 Deref 强制转换：</p>
<ul>
<li>当 <code>T: Deref&lt;Target=U&gt;</code> 时从 <code>&amp;T</code> 到 <code>&amp;U</code>。</li>
<li>当 <code>T: DerefMut&lt;Target=U&gt;</code> 时从 <code>&amp;mut T</code> 到 <code>&amp;mut U</code>。</li>
<li>当 <code>T: Deref&lt;Target=U&gt;</code> 时从 <code>&amp;mut T</code> 到 <code>&amp;U</code>。</li>
<li></li>
</ul>
<p>第三个情况有些微妙：Rust 也会将可变引用强转为不可变引用。但是反之是 <strong>不可能</strong> 的</p>
<p>因为根据借用规则，如果有一个可变引用，其必须是这些数据的唯一引用（否则程序将无法编译）。将一个可变引用转换为不可变引用永远也不会打破借用规则。</p>
<h3 id="使用-Drop-Trait-运行清理代码"><a href="#使用-Drop-Trait-运行清理代码" class="headerlink" title="使用 Drop Trait 运行清理代码"></a>使用 Drop Trait 运行清理代码</h3><p>对于智能指针模式来说第二个重要的 trait 是 <code>Drop</code>，其允许我们在值要离开作用域时执行一些代码。</p>
<p><code>Drop</code> trait 包含在 prelude 中</p>
<p>变量以被创建时<strong>相反的顺序</strong>被丢弃</p>
<h4 id="通过-std-mem-drop-提早丢弃值"><a href="#通过-std-mem-drop-提早丢弃值" class="headerlink" title="通过 std::mem::drop 提早丢弃值"></a>通过 <code>std::mem::drop</code> 提早丢弃值</h4><p>我们并不能直截了当的禁用 <code>drop</code> 这个功能。通常也不需要禁用 <code>drop</code> ；整个 <code>Drop</code> trait 存在的意义在于其是自动处理的。</p>
<p>Rust 不允许我们显式调用 <code>drop</code> 因为 Rust 仍然会在 <code>main</code> 的结尾对值自动调用 <code>drop</code>，这会导致一个 <strong>double free</strong> 错误，因为 Rust 会尝试清理相同的值两次。</p>
<p>如果我们需要强制提早清理值，可以使用 <code>std::mem::drop</code> 函数。</p>
<p><code>std::mem::drop</code> 函数不同于 <code>Drop</code> trait 中的 <code>drop</code> 方法。可以通过传递希望提早强制丢弃的值作为参数。<code>std::mem::drop</code> 位于 prelude</p>
<h3 id="Rc-引用计数智能指针"><a href="#Rc-引用计数智能指针" class="headerlink" title="Rc 引用计数智能指针"></a>Rc<T> 引用计数智能指针</h3><p><code>Rc&lt;T&gt;</code> 用于当我们希望在堆上分配一些内存供程序的多个部分读取，而且<strong>无法在编译时确定</strong>程序的哪一部分会最后结束使用它的时候。</p>
<p>如果确实知道哪部分是最后一个结束使用的话，就可以令其成为数据的所有者，正常的所有权规则就可以在编译时生效</p>
<p> <code>Rc&lt;T&gt;</code> 只能用于单线程场景；第十六章并发会涉及到如何在多线程程序中进行引用计数。</p>
<p><code>Rc::clone</code> 只会增加引用计数。当查找代码中的性能问题时，只需考虑深拷贝类的克隆而无需考虑 <code>Rc::clone</code> 调用</p>
<p><code>Rc::strong_count</code> 查看引用计数</p>
<p>不必像调用 <code>Rc::clone</code> 增加引用计数那样调用一个函数来减少计数；<code>Drop</code> trait 的实现当 <code>Rc&lt;T&gt;</code> 值离开作用域时自动减少引用计数。</p>
<p>通过不可变引用， <code>Rc&lt;T&gt;</code> 允许在程序的多个部分之间只读地共享数据</p>
<p>如果 <code>Rc&lt;T&gt;</code> 也允许多个可变引用，则会违反第四章讨论的借用规则之一：相同位置的多个可变借用可能造成数据竞争和不一致。不过可以修改数据是非常有用的！</p>
<p>我们将讨论内部可变性模式和 <code>RefCell&lt;T&gt;</code> 类型，它可以与 <code>Rc&lt;T&gt;</code> 结合使用来处理不可变性的限制</p>
<h3 id="RefCell-和内部可变性模式"><a href="#RefCell-和内部可变性模式" class="headerlink" title="RefCell 和内部可变性模式"></a><code>RefCell</code> 和内部可变性模式</h3><p><strong>内部可变性</strong>（<em>Interior mutability</em>）是 Rust 中的一个设计模式，它允许你即使在有不可变引用时也可以改变数据，这通常是借用规则所不允许的。</p>
<p>该模式在数据结构中使用 <code>unsafe</code> 代码来模糊 Rust 通常的可变性和借用规则。</p>
<p>借用规则：</p>
<ol>
<li>在任意给定时刻，只能拥有一个可变引用或任意数量的不可变引用 <strong>之一</strong>（而不是两者）。</li>
<li>引用必须总是有效的。</li>
</ol>
<p>对于引用和 <code>Box&lt;T&gt;</code>，借用规则的不可变性作用于编译时。对于 <code>RefCell&lt;T&gt;</code>，这些不可变性作用于 <strong>运行时</strong>。</p>
<p>对于引用，如果违反这些规则，会得到一个编译错误。而对于 <code>RefCell&lt;T&gt;</code>，如果违反这些规则程序会 panic 并退出。</p>
<p>静态分析总是保守的，如果 Rust 拒绝正确的程序，虽然会给程序员带来不便，但不会带来灾难。<code>RefCell&lt;T&gt;</code> 正是用于当你确信代码遵守借用规则，而编译器不能理解和确定的时候。</p>
<p><code>RefCell&lt;T&gt;</code> 只能用于单线程场景。</p>
<p><img src="/2022/07/22/%5B%E5%A4%87%E5%BF%98%E5%BD%95%5D%5BRust%5D/image-20220806180613257.png" alt="image-20220806180613257"></p>
<p>在不可变值内部改变值就是 <strong>内部可变性</strong> 模式。</p>
<p>特定情况下，令一个值在其方法内部能够修改自身，而在其他代码中仍视为不可变，是很有用的。值方法外部的代码就不能修改其值了。</p>
<p><code>RefCell&lt;T&gt;</code> 并没有完全绕开借用规则，编译器中的借用检查器允许内部可变性并相应地在运行时检查借用规则。如果违反了这些规则，会出现 panic 而不是编译错误。</p>
<p><strong>测试替身</strong>（<em>test double</em>）是一个通用编程概念，它代表一个在测试中替代某个类型的类型。<strong>mock 对象</strong> 是特定类型的测试替身，它们记录测试过程中发生了什么以便可以断言操作是正确的。</p>
<p><img src="/2022/07/22/%5B%E5%A4%87%E5%BF%98%E5%BD%95%5D%5BRust%5D/image-20220806190309273.png" alt="image-20220806190309273"></p>
<p><img src="/2022/07/22/%5B%E5%A4%87%E5%BF%98%E5%BD%95%5D%5BRust%5D/image-20220806190329332.png" alt="image-20220806190329332"></p>
<h4 id="将Rc-和-RefCell结合来拥有多个可变数据所有者"><a href="#将Rc-和-RefCell结合来拥有多个可变数据所有者" class="headerlink" title="将Rc 和 RefCell结合来拥有多个可变数据所有者"></a>将Rc<T> 和 RefCell<T>结合来拥有多个可变数据所有者</h4><p>回忆一下 <code>Rc&lt;T&gt;</code> 允许对相同数据有多个所有者，不过只能提供数据的不可变访问。如果有一个储存了 <code>RefCell&lt;T&gt;</code> 的 <code>Rc&lt;T&gt;</code> 的话，就可以得到有多个所有者 <strong>并且</strong> 可以修改的值了！</p>
<p><code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> 实例并储存在变量 <code>value</code> 中以便之后直接访问。</p>
<p>Cell<T>并非提供内部值的引用，而是把值拷贝进和拷贝出 <code>Cell&lt;T&gt;</code></p>
<p><code>Mutex&lt;T&gt;</code>，其提供线程间安全的内部可变性</p>
<p><a target="_blank" rel="noopener" href="https://www.coder.work/article/2560778">rust - Rc&lt;RefCell<T>&gt; 和 RefCell&lt;Rc<T>&gt; 有什么区别？</a></p>
<h3 id="循环引用导致内存泄露"><a href="#循环引用导致内存泄露" class="headerlink" title="循环引用导致内存泄露"></a>循环引用导致内存泄露</h3><h4 id="避免引用循环：将-Rc-变为-Weak"><a href="#避免引用循环：将-Rc-变为-Weak" class="headerlink" title="避免引用循环：将 Rc 变为 Weak"></a>避免引用循环：将 <code>Rc</code> 变为 <code>Weak</code></h4><p> <code>Rc::downgrade</code> 并传递 <code>Rc&lt;T&gt;</code> 实例的引用来创建其值的 <strong>弱引用</strong>（<em>weak reference</em>）</p>
<p>调用 <code>Rc::downgrade</code> 时会得到 <code>Weak&lt;T&gt;</code> 类型的智能指针。</p>
<p>调用 <code>Rc::downgrade</code> 会将 <code>weak_count</code> 加 1。</p>
<p><code>Rc&lt;T&gt;</code> 类型使用 <code>weak_count</code> 来记录其存在多少个 <code>Weak&lt;T&gt;</code> 引用，类似于 <code>strong_count</code>。其区别在于 <code>weak_count</code> 无需计数为 0 就能使 <code>Rc&lt;T&gt;</code> 实例被清理。</p>
<p>强引用代表如何共享 <code>Rc&lt;T&gt;</code> 实例的所有权，但弱引用并不属于所有权关系。</p>
<p>为了使用 <code>Weak&lt;T&gt;</code> 所指向的值，我们必须确保其值仍然有效。为此可以调用 <code>Weak&lt;T&gt;</code> 实例的 <code>upgrade</code> 方法，这会返回 <code>Option&lt;Rc&lt;T&gt;&gt;</code>。</p>
<p>如果 <code>Rc&lt;T&gt;</code> 值还未被丢弃，则结果是 <code>Some</code>；如果 <code>Rc&lt;T&gt;</code> 已被丢弃，则结果是 <code>None</code>。</p>
<p>例子：</p>
<p>​	建立树，父对子 是strong_count, 子对父则是 weak_count.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    value: <span class="type">i32</span>,</span><br><span class="line">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,      <span class="comment">// 子对父 </span></span><br><span class="line">    children: RefCell&lt;<span class="type">Vec</span>&lt;Rc&lt;Node&gt;&gt;&gt;, <span class="comment">// 父对子 RefCell 内部是 Vec 套着Rc</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">leaf</span> = Rc::<span class="title function_ invoke__">new</span>(Node &#123;</span><br><span class="line">        value: <span class="number">3</span>,</span><br><span class="line">        parent: RefCell::<span class="title function_ invoke__">new</span>(Weak::<span class="title function_ invoke__">new</span>()),</span><br><span class="line">        children: RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[]),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;leaf strong = &#123;&#125;, weak = &#123;&#125;&quot;</span>,</span><br><span class="line">        Rc::<span class="title function_ invoke__">strong_count</span>(&amp;leaf),</span><br><span class="line">        Rc::<span class="title function_ invoke__">weak_count</span>(&amp;leaf),</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">branch</span> = Rc::<span class="title function_ invoke__">new</span>(Node &#123;</span><br><span class="line">            value: <span class="number">5</span>,</span><br><span class="line">            parent: RefCell::<span class="title function_ invoke__">new</span>(Weak::<span class="title function_ invoke__">new</span>()),</span><br><span class="line">            children: RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[Rc::<span class="title function_ invoke__">clone</span>(&amp;leaf)]), <span class="comment">// 父对子 strong_count</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        *leaf.parent.<span class="title function_ invoke__">borrow_mut</span>() = Rc::<span class="title function_ invoke__">downgrade</span>(&amp;branch); <span class="comment">// 子对父 weak_count</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(</span><br><span class="line">            <span class="string">&quot;branch strong = &#123;&#125;, weak = &#123;&#125;&quot;</span>,</span><br><span class="line">            Rc::<span class="title function_ invoke__">strong_count</span>(&amp;branch),</span><br><span class="line">            Rc::<span class="title function_ invoke__">weak_count</span>(&amp;branch),</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(</span><br><span class="line">            <span class="string">&quot;leaf strong = &#123;&#125;, weak = &#123;&#125;&quot;</span>,</span><br><span class="line">            Rc::<span class="title function_ invoke__">strong_count</span>(&amp;leaf),</span><br><span class="line">            Rc::<span class="title function_ invoke__">weak_count</span>(&amp;leaf),</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;leaf parent = &#123;:?&#125;&quot;</span>, leaf.parent.<span class="title function_ invoke__">borrow</span>().<span class="title function_ invoke__">upgrade</span>()); <span class="comment">// upgrade,已经None</span></span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;leaf strong = &#123;&#125;, weak = &#123;&#125;&quot;</span>,</span><br><span class="line">        Rc::<span class="title function_ invoke__">strong_count</span>(&amp;leaf),</span><br><span class="line">        Rc::<span class="title function_ invoke__">weak_count</span>(&amp;leaf),</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="无畏并发"><a href="#无畏并发" class="headerlink" title="无畏并发"></a>无畏并发</h2><p>很多操作系统提供了创建新线程的 API。这种由编程语言调用操作系统 API 创建线程的模型有时被称为 <em>1:1</em></p>
<p>thread::spawn(|| { … })</p>
<p>当主线程结束时，新线程也会结束，而不管其是否执行完毕。</p>
<p>通过将 <code>thread::spawn</code> 的返回值储存在变量中来修复新建线程部分没有执行或者完全没有执行的问题。<code>thread::spawn</code> 的返回值类型是 <code>JoinHandle</code>。<code>JoinHandle</code> 是一个拥有所有权的值，当对其调用 <code>join</code> 方法时，它会等待其线程结束。</p>
<h3 id="线程与-move-闭包"><a href="#线程与-move-闭包" class="headerlink" title="线程与 move 闭包"></a>线程与 move 闭包</h3><p><code>move</code> 关键字经常用于传递给 <code>thread::spawn</code> 的闭包，因为闭包会获取从环境中取得的值的所有权，因此会将这些值的所有权从一个线程传送到另一个线程。</p>
<h3 id="使用消息传递在线程间传送数据"><a href="#使用消息传递在线程间传送数据" class="headerlink" title="使用消息传递在线程间传送数据"></a>使用消息传递在线程间传送数据</h3><p>Rust 中一个实现消息传递并发的主要工具是 <strong>信道</strong>（<em>channel</em>）</p>
<p>当发送者或接收者任一被丢弃时可以认为信道被 <strong>关闭</strong>（<em>closed</em>）了</p>
<p>这里使用 <code>mpsc::channel</code> 函数创建一个新的信道；<code>mpsc</code> 是 <strong>多个生产者，单个消费者</strong>（<em>multiple producer, single consumer</em>）</p>
<p>信道的接收端有两个有用的方法：<code>recv</code> 和 <code>try_recv</code>。</p>
<p> <code>recv</code>，这个方法会<strong>阻塞</strong>主线程执行直到从信道中接收一个值。一旦发送了一个值，<code>recv</code> 会在一个 <code>Result&lt;T, E&gt;</code> 中返回它。当信道发送端关闭，<code>recv</code> 会返回一个错误表明不会再有新的值到来了。</p>
<p><code>try_recv</code> <strong>不会阻塞</strong>，相反它立刻返回一个 <code>Result&lt;T, E&gt;</code>：<code>Ok</code> 值包含可用的信息，而 <code>Err</code> 值代表此时没有任何消息。如果线程在等待消息过程中还有其他工作时使用 <code>try_recv</code> 很有用：可以编写一个循环来频繁调用 <code>try_recv</code>，在有可用消息时进行处理，其余时候则处理一会其他工作直到再次检查。</p>
<h4 id="信道与所有权转移"><a href="#信道与所有权转移" class="headerlink" title="信道与所有权转移"></a>信道与所有权转移</h4><p>move 与 thread::spawn 结合，将 所有权转移至 闭包内部</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">val</span> = String::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">        tx.<span class="title function_ invoke__">send</span>(val).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="comment">//println!(&quot;val is &#123;&#125;&quot;, val);  //error!</span></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>发送完成之后, val 的所有权转移给了接受者</p>
<h4 id="通过克隆发送者来创建多个生产者"><a href="#通过克隆发送者来创建多个生产者" class="headerlink" title="通过克隆发送者来创建多个生产者"></a>通过克隆发送者来创建多个生产者</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">tx1</span> = mspc::Sender::<span class="title function_ invoke__">clone</span>(&amp;tx); <span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">tx2</span> = tx.<span class="title function_ invoke__">clone</span>();  <span class="comment">// 创建多个发送方</span></span><br></pre></td></tr></table></figure>



<h3 id="共享状态并发"><a href="#共享状态并发" class="headerlink" title="共享状态并发"></a>共享状态并发</h3><p><strong>互斥器</strong>（<em>mutex</em>）是 <em>mutual exclusion</em> 的缩写，也就是说，任意时刻，其只允许一个线程访问某些数据。</p>
<ol>
<li>在使用数据之前尝试获取锁。</li>
<li>处理完被互斥器所保护的数据之后，必须解锁数据，这样其他线程才能够获取锁。</li>
</ol>
<p>使用关联函数 <code>new</code> 来创建一个 <code>Mutex&lt;T&gt;</code></p>
<p>如果另一个线程拥有锁，并且那个线程 panic 了，则 <code>lock</code> 调用会失败。在这种情况下，没人能够再获取锁，所以这里选择 <code>unwrap</code> 并在遇到这种情况时使线程 panic。</p>
<p><code>Mutex&lt;T&gt;</code> 是一个智能指针。更准确的说，<code>lock</code> 调用 <strong>返回</strong> 一个叫做 <code>MutexGuard</code> 的智能指针。这个智能指针实现了 <code>Deref</code> 来指向其内部数据；其也提供了一个 <code>Drop</code> 实现当 <code>MutexGuard</code> 离开作用域时自动释放锁</p>
<h4 id="在线程间共享-Mutex"><a href="#在线程间共享-Mutex" class="headerlink" title="在线程间共享 Mutex"></a>在线程间共享 <code>Mutex</code></h4><p> 直接move和Rc<T> 失效</p>
<h5 id="原子引用计数-Arc"><a href="#原子引用计数-Arc" class="headerlink" title="原子引用计数 Arc"></a>原子引用计数 <code>Arc</code></h5><p><img src="/2022/07/22/%5B%E5%A4%87%E5%BF%98%E5%BD%95%5D%5BRust%5D/image-20220807185618825.png" alt="image-20220807185618825"></p>
<h3 id="使用-Sync-和-Send-trait-的可扩展并发"><a href="#使用-Sync-和-Send-trait-的可扩展并发" class="headerlink" title="使用 Sync 和 Send trait 的可扩展并发"></a>使用 <code>Sync</code> 和 <code>Send</code> trait 的可扩展并发</h3><p>两个并发概念是内嵌于语言中的：<code>std::marker</code> 中的 <code>Sync</code> 和 <code>Send</code> trait。</p>
<p><code>Send</code> 标记 trait 表明实现了 <code>Send</code> 的类型值的所有权可以在线程间传送。</p>
<p>不过有一些例外，包括 <code>Rc&lt;T</code>，<code>Rc&lt;T&gt;</code> 被实现为用于单线程场景</p>
<p>任何完全由 <code>Send</code> 的类型组成的类型也会自动被标记为 <code>Send</code>。</p>
<p>几乎所有基本类型都是 <code>Send</code> 的，除了第十九章将会讨论的裸指针（raw pointer）。</p>
<p><code>Sync</code> 标记 trait 表明一个实现了 <code>Sync</code> 的类型可以安全的在多个线程中拥有其值的引用。</p>
<p>对于任意类型 <code>T</code>，如果 <code>&amp;T</code>（<code>T</code> 的不可变引用）是 <code>Send</code> 的话 <code>T</code> 就是 <code>Sync</code> 的，这意味着其引用就可以安全的发送到另一个线程。</p>
<p>类似于 <code>Send</code> 的情况，基本类型是 <code>Sync</code> 的，完全由 <code>Sync</code> 的类型组成的类型也是 <code>Sync</code> 的。</p>
<p>智能指针 <code>Rc&lt;T&gt;</code> 也不是 <code>Sync</code> 的</p>
<p><code>RefCell&lt;T&gt;</code>和 <code>Cell&lt;T&gt;</code> 系列类型不是 <code>Sync</code> 的。</p>
<p><code>RefCell&lt;T&gt;</code> 在运行时所进行的借用检查也不是线程安全的。</p>
<p><code>Mutex&lt;T&gt;</code> 是 <code>Sync</code> 的，它可以被用来在多线程中共享访问。</p>
<h2 id="Rust-面向对象-编程特性"><a href="#Rust-面向对象-编程特性" class="headerlink" title="Rust 面向对象 编程特性"></a>Rust 面向对象 编程特性</h2><h3 id="对象包含数据和行为"><a href="#对象包含数据和行为" class="headerlink" title="对象包含数据和行为"></a>对象包含数据和行为</h3><p>面向对象的程序是由对象组成的。一个 <strong>对象</strong> 包含数据和操作这些数据的过程。这些过程通常被称为 <strong>方法</strong> 或 <strong>操作</strong>。</p>
<h3 id="封装隐藏了实现细节"><a href="#封装隐藏了实现细节" class="headerlink" title="封装隐藏了实现细节"></a>封装隐藏了实现细节</h3><p>注意，结构体自身被标记为 <code>pub</code>，这样其他代码就可以使用这个结构体，但是在结构体内部的字段仍然是私有的。</p>
<h3 id="继承，作为类型系统与代码共享"><a href="#继承，作为类型系统与代码共享" class="headerlink" title="继承，作为类型系统与代码共享"></a>继承，作为类型系统与代码共享</h3><p>第一个是为了重用代码</p>
<p>​	Rust 代码可以使用默认 trait 方法实现来进行共享</p>
<p>第二个使用继承的原因与类型系统有关：表现为子类型可以用于父类型被使用的地方。这也被称为 <strong>多态</strong>（<em>polymorphism</em>），这意味着如果多种对象共享特定的属性，则可以相互替代使用。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        String::<span class="title function_ invoke__">from</span>(<span class="string">&quot;(Read more...)&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">NewsArticle</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> headline: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> location: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> author: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">NewsArticle</span> &#123;&#125; <span class="comment">// 默认实现</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>近来继承作为一种语言设计的解决方案在很多语言中失宠了，因为其时常带有共享多于所需的代码的风险。</p>
<p>Rust 则通过<strong>泛型</strong>来对不同的可能类型进行抽象，并通过 <strong>trait bounds</strong> 对这些类型所必须提供的内容施加约束。</p>
<hr>
<p><strong>trait 对象指向一个实现了我们指定 trait 的类型的实例，以及一个用于在运行时查找该类型的trait方法的表。</strong></p>
<p>我们通过指定某种指针来创建 trait 对象，例如 <code>&amp;</code> 引用或 <code>Box&lt;T&gt;</code> 智能指针，还有 <code>dyn</code> keyword， 以及指定相关的 trait</p>
<p>我们可以使用 trait 对象代替泛型或具体类型。任何使用 trait 对象的位置，Rust 的类型系统会在编译时确保任何在此上下文中使用的值会实现其 trait 对象的 trait。</p>
<hr>
<p>这与定义使用了带有 trait bound 的泛型类型参数的结构体不同。泛型类型参数一次只能替代一个具体类型，而 trait 对象则允许在运行时替代多种具体类型。</p>
<p>这个 vector 的类型是 <code>Box&lt;dyn Draw&gt;</code>，此为一个 trait 对象：它是 <code>Box</code> 中任何实现了 <code>Draw</code> trait 的类型的替身。</p>
<p>如果只需要同质（相同类型）集合，则倾向于使用泛型和 trait bound，因为其定义会在编译时采用具体类型进行单态化。</p>
<p>通过使用 trait 对象的方法，一个 <code>Screen</code> 实例可以存放一个既能包含 <code>Box&lt;Button&gt;</code>，也能包含 <code>Box&lt;TextField&gt;</code> 的 <code>Vec&lt;T&gt;</code></p>
<p>单态化所产生的代码进行 <strong>静态分发</strong>（<em>static dispatch</em>）。静态分发发生于编译器在编译时就知晓调用了什么方法的时候。</p>
<p>这与 <strong>动态分发</strong> （<em>dynamic dispatch</em>）相对，这时编译器在编译时无法知晓调用了什么方法。在动态分发的情况下，编译器会生成在运行时确定调用了什么方法的代码。</p>
<p>当使用 trait 对象时，Rust 必须使用动态分发。编译器无法知晓所有可能用于 trait 对象代码的类型，所以它也不知道应该调用哪个类型的哪个方法实现。为此，Rust 在运行时使用 trait 对象中的指针来知晓需要调用哪个方法。</p>
<p>动态分发也阻止编译器有选择的内联方法代码，这会相应的禁用一些优化。</p>
<p>只有对象安全（object-safe）的trait可以实现为特征对象。</p>
<p>如果一个 trait 中定义的所有方法都符合以下规则，则该 trait 是对象安全的：</p>
<ul>
<li>返回值不是 <code>Self</code></li>
<li>没有泛型类型的参数</li>
</ul>
<p><code>Self</code> 关键字是我们在 trait 与方法上的实现的别称，trait 对象必须是对象安全的，因为一旦使用 trait 对象，Rust 将不再知晓该实现的返回类型。<strong>如果一个 trait 的方法返回了一个 <code>Self</code> 类型，但是该 trait 对象忘记了 <code>Self</code> 的确切类型，那么该方法将不能使用原本的类型。</strong></p>
<p>当 trait 使用具体类型填充的泛型类型时也一样：具体类型成为实现 trait 的对象的一部分，<strong>当使用 trait 对象却忘了类型是什么时，无法知道应该用什么类型来填充泛型类型。</strong></p>
<p>一个非对象安全的 trait 例子是标准库中的 <code>Clone</code> trait。<code>Clone</code> trait 中的 <code>clone</code> 方法的声明如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Clone</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">clone</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="面向对象设计模式的实现"><a href="#面向对象设计模式的实现" class="headerlink" title="面向对象设计模式的实现"></a>面向对象设计模式的实现</h3><p><strong>状态模式</strong>（<em>state pattern</em>）是一个面向对象设计模式。该模式的关键在于一个值有某些内部状态，体现为一系列的 <strong>状态对象</strong>，同时值的行为随着其内部状态而改变。</p>
<p>每一个状态对象负责其自身的行为，以及该状态何时应当转移至另一个状态。持有一个状态对象的值对于不同状态的行为以及何时状态转移毫不知情。</p>
<h2 id="模式与模式匹配"><a href="#模式与模式匹配" class="headerlink" title="模式与模式匹配"></a>模式与模式匹配</h2><p>模式是 Rust 中特殊的语法，<strong>它用来匹配类型中的结构</strong>，无论类型是简单还是复杂。</p>
<p>模式由如下一些内容组合而成：</p>
<ul>
<li>字面值</li>
<li>解构的数组、枚举、结构体或者元组</li>
<li>变量</li>
<li>通配符</li>
<li>占位符</li>
</ul>
<p><strong>match 分支</strong></p>
<p><strong>if let 条件表达式</strong></p>
<p>可以组合并匹配 <code>if let</code>、<code>else if</code> 和 <code>else if let</code> 表达式。</p>
<p><strong>while let 条件循环</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">stack</span> = Vec::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">stack.<span class="title function_ invoke__">push</span>(<span class="number">1</span>);</span><br><span class="line">stack.<span class="title function_ invoke__">push</span>(<span class="number">2</span>);</span><br><span class="line">stack.<span class="title function_ invoke__">push</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Some</span>(top) = stack.<span class="title function_ invoke__">pop</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, top);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>for 循环</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">for</span> (index, value) <span class="keyword">in</span> v.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; is at index &#123;&#125;&quot;</span>, value, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>let 语句</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let PATTERN = EXPRESSION;</span><br></pre></td></tr></table></figure>

<p> <code>let x = 5;</code> 这样的语句中变量名位于 <code>PATTERN</code> 位置，变量名不过是形式特别朴素的模式。</p>
<p>我们将表达式与模式比较，并为任何找到的名称赋值。所以例如 <code>let x = 5;</code> 的情况，<code>x</code> 是一个代表 “将匹配到的值绑定到变量 x” 的模式。同时因为名称 <code>x</code> 是整个模式，这个模式实际上等于 “将任何值绑定到变量 <code>x</code>，不管值是什么”。</p>
<p><strong>函数参数</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">foo</span>(x: <span class="type">i32</span>) &#123;</span><br><span class="line">    <span class="comment">// code goes here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>x</code> 部分就是一个模式！类似于之前对 <code>let</code> 所做的，可以在函数参数中匹配元组。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">print_coordinates</span>(&amp;(x, y): &amp;(<span class="type">i32</span>, <span class="type">i32</span>)) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Current location: (&#123;&#125;, &#123;&#125;)&quot;</span>, x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">point</span> = (<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="title function_ invoke__">print_coordinates</span>(&amp;point);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因为如第十三章所讲闭包类似于函数，也可以在闭包参数列表中使用模式。</p>
<h3 id="Refutability（可反驳性）-模式是否会匹配失效"><a href="#Refutability（可反驳性）-模式是否会匹配失效" class="headerlink" title="Refutability（可反驳性）: 模式是否会匹配失效"></a>Refutability（可反驳性）: 模式是否会匹配失效</h3><p>模式有两种形式：refutable（可反驳的）和 irrefutable（不可反驳的）。</p>
<p><strong>能匹配任何传递的可能值的模式被称为是</strong> <strong>不可反驳的</strong>（<em>irrefutable</em>）。</p>
<p>一个例子就是 <code>let x = 5;</code> 语句中的 <code>x</code>，因为 <code>x</code> 可以匹配任何值所以不可能会失败。</p>
<p>对某些可能的值进行匹配会失败的模式被称为是 <strong>可反驳的</strong>（<em>refutable</em>）</p>
<p>。一个这样的例子便是 <code>if let Some(x) = a_value</code> 表达式中的 <code>Some(x)</code>；如果变量 <code>a_value</code> 中的值是 <code>None</code> 而不是 <code>Some</code>，那么 <code>Some(x)</code> 模式不能匹配。</p>
<p>函数参数、 <code>let</code> 语句和 <code>for</code> 循环只能接受<strong>不可反驳的模式</strong>，因为通过不匹配的值程序无法进行有意义的工作。</p>
<p><code>if let</code> 和 <code>while let</code> 表达式被限制为只能接受<strong>可反驳的模式</strong>，因为根据定义他们意在处理可能的失败：条件表达式的功能就是根据成功或失败执行不同的操作。</p>
<p>Rust 会抱怨将不可反驳模式用于 <code>if let</code> 是没有意义的：</p>
<p>基于此，<code>match</code><strong>匹配分支</strong>必须使用<strong>可反驳模式</strong>，除了<strong>最后一个分支</strong>需要使用能匹配任何剩余值的<strong>不可反驳模式</strong>。Rust允许我们在只有一个匹配分支的<code>match</code>中使用不可反驳模式，可以用<code>if let</code>。</p>
<h3 id="所有的模式语法"><a href="#所有的模式语法" class="headerlink" title="所有的模式语法"></a>所有的模式语法</h3><p><strong>匹配字面值</strong></p>
<p><strong>匹配命名变量</strong></p>
<p>用于 <code>match</code> 表达式时，因为 <code>match</code> 会开始一个新作用域，<code>match</code> 表达式中作为模式的一部分声明的变量会覆盖 <code>match</code> 结构之外的同名变量。</p>
<p><strong>多个模式</strong></p>
<p>在 match 表达式中，可以使用 | 语法匹配多个模式，它代表 或（or）的意思。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="number">1</span> | <span class="number">2</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;one or two&quot;</span>),</span><br><span class="line">        <span class="number">3</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;three&quot;</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;anything&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="通过-x3D-匹配值的范围"><a href="#通过-x3D-匹配值的范围" class="headerlink" title="通过 ..&#x3D; 匹配值的范围"></a><strong>通过 ..&#x3D; 匹配值的范围</strong></h4><p><code>..=</code> 语法允许你匹配一个闭区间范围内的值。</p>
<p>除了数字字面值之外，还可以匹配char</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="string">&#x27;a&#x27;</span>..=<span class="string">&#x27;j&#x27;</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;early ASCII letter&quot;</span>),</span><br><span class="line">        <span class="string">&#x27;k&#x27;</span>..=<span class="string">&#x27;z&#x27;</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;late ASCII letter&quot;</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;something else&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="解构并分解值"><a href="#解构并分解值" class="headerlink" title="解构并分解值"></a>解构并分解值</h4><p>使用模式来解构结构体、枚举和元组，以便使用这些值的不同部分。</p>
<h5 id="解构结构体"><a href="#解构结构体" class="headerlink" title="解构结构体"></a><strong>解构结构体</strong></h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Point &#123; x: <span class="number">0</span>, y: <span class="number">7</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">Point</span> &#123; x: a, y: b &#125; = p;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">0</span>, a);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">7</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>因为变量名匹配字段名是常见的，同时因为 <code>let Point &#123; x: x, y: y &#125; = p;</code> 包含了很多重复，所以对于匹配结构体字段的模式存在简写：只需列出结构体字段的名称，则模式创建的变量会有相同的名称。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">p</span> = Point &#123; x: <span class="number">0</span>, y: <span class="number">7</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">Point</span> &#123; x, y &#125; = p;</span><br><span class="line"><span class="built_in">assert_eq!</span>(<span class="number">0</span>, x);</span><br><span class="line"><span class="built_in">assert_eq!</span>(<span class="number">7</span>, y);</span><br></pre></td></tr></table></figure>



<p>使用字面值作为结构体模式的一部分进行解构，而不是为所有的字段创建变量</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">p</span> = Point &#123; x: <span class="number">0</span>, y: <span class="number">7</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> p &#123;</span><br><span class="line">Point &#123; x, y: <span class="number">0</span> &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;On the x axis at &#123;&#125;&quot;</span>, x),</span><br><span class="line">Point &#123; x: <span class="number">0</span>, y &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;On the y axis at &#123;&#125;&quot;</span>, y),</span><br><span class="line">Point &#123; x, y &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;On neither axis: (&#123;&#125;, &#123;&#125;)&quot;</span>, x, y),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个分支通过指定字段 <code>y</code> 匹配字面值 <code>0</code> 来匹配任何位于 <code>x</code> 轴上的点,此模式仍然创建了变量 <code>x</code> 以便在分支的代码中使用。</p>
<p>第二个分支通过指定字段 <code>x</code> 匹配字面值 <code>0</code> 来匹配任何位于 <code>y</code> 轴上的点，并为字段 <code>y</code> 创建了变量 <code>y</code>。</p>
<h5 id="解构枚举"><a href="#解构枚举" class="headerlink" title="解构枚举"></a><strong>解构枚举</strong></h5><p>解构枚举的模式需要对应枚举所定义的储存数据的方式。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123; x: <span class="type">i32</span>, y: <span class="type">i32</span> &#125;,</span><br><span class="line">    <span class="title function_ invoke__">Write</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">ChangeColor</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">msg</span> = Message::<span class="title function_ invoke__">ChangeColor</span>(<span class="number">0</span>, <span class="number">160</span>, <span class="number">255</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> msg &#123;</span><br><span class="line">        Message::Quit =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;The Quit variant has no data to destructure.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        Message::Move &#123; x, y &#125; =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(</span><br><span class="line">                <span class="string">&quot;Move in the x direction &#123;&#125; and in the y direction &#123;&#125;&quot;</span>,</span><br><span class="line">                x, y</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        Message::<span class="title function_ invoke__">Write</span>(text) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Text message: &#123;&#125;&quot;</span>, text),</span><br><span class="line">        Message::<span class="title function_ invoke__">ChangeColor</span>(r, g, b) =&gt; <span class="built_in">println!</span>(</span><br><span class="line">            <span class="string">&quot;Change the color to red &#123;&#125;, green &#123;&#125;, and blue &#123;&#125;&quot;</span>,</span><br><span class="line">            r, g, b</span><br><span class="line">        ),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于像 <code>Message::Quit</code> 这样没有任何数据的枚举成员，不能进一步解构其值。只能匹配其字面值 <code>Message::Quit</code>，因此模式中没有任何变量。</p>
<p>对于像 <code>Message::Move</code> 这样的类结构体枚举成员，可以采用类似于匹配结构体的模式。</p>
<p>对于像 <code>Message::Write</code> 这样的包含一个元素，以及像 <code>Message::ChangeColor</code> 这样包含三个元素的类元组枚举成员，其模式则类似于用于解构元组的模式。模式中变量的数量必须与成员中元素的数量一致。</p>
<h5 id="解构嵌套的结构体和枚举"><a href="#解构嵌套的结构体和枚举" class="headerlink" title="解构嵌套的结构体和枚举"></a>解构嵌套的结构体和枚举</h5><p>当然也可以匹配嵌套的项！</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Rgb</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>),</span><br><span class="line">    <span class="title function_ invoke__">Hsv</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123; x: <span class="type">i32</span>, y: <span class="type">i32</span> &#125;,</span><br><span class="line">    <span class="title function_ invoke__">Write</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">ChangeColor</span>(Color),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">msg</span> = Message::<span class="title function_ invoke__">ChangeColor</span>(Color::<span class="title function_ invoke__">Hsv</span>(<span class="number">0</span>, <span class="number">160</span>, <span class="number">255</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> msg &#123;</span><br><span class="line">        Message::<span class="title function_ invoke__">ChangeColor</span>(Color::<span class="title function_ invoke__">Rgb</span>(r, g, b)) =&gt; <span class="built_in">println!</span>(</span><br><span class="line">            <span class="string">&quot;Change the color to red &#123;&#125;, green &#123;&#125;, and blue &#123;&#125;&quot;</span>,</span><br><span class="line">            r, g, b</span><br><span class="line">        ),</span><br><span class="line">        Message::<span class="title function_ invoke__">ChangeColor</span>(Color::<span class="title function_ invoke__">Hsv</span>(h, s, v)) =&gt; <span class="built_in">println!</span>(</span><br><span class="line">            <span class="string">&quot;Change the color to hue &#123;&#125;, saturation &#123;&#125;, and value &#123;&#125;&quot;</span>,</span><br><span class="line">            h, s, v</span><br><span class="line">        ),</span><br><span class="line">        _ =&gt; (),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="解构结构体和元组"><a href="#解构结构体和元组" class="headerlink" title="解构结构体和元组"></a>解构结构体和元组</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ((feet, inches), Point &#123; x, y &#125;) = ((<span class="number">3</span>, <span class="number">10</span>), Point &#123; x: <span class="number">3</span>, y: -<span class="number">10</span> &#125;);</span><br></pre></td></tr></table></figure>



<h4 id="忽略模式中的值"><a href="#忽略模式中的值" class="headerlink" title="忽略模式中的值"></a>忽略模式中的值</h4><p>使用过下划线（<code>_</code>）作为匹配但不绑定任何值的通配符模式了</p>
<p>虽然 <code>_</code> 模式作为 <code>match</code> 表达式最后的分支特别有用，也可以将其用于任意模式，包括函数参数中</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">foo</span>(_: <span class="type">i32</span>, y: <span class="type">i32</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;This code only uses the y parameter: &#123;&#125;&quot;</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大部分情况当你不再需要特定函数参数时，最好修改签名不再包含无用的参数。在一些情况下忽略函数参数会变得特别有用，比如实现 trait 时，<strong>当你需要特定类型签名但是函数实现并不需要某个参数时</strong>。此时编译器就不会警告说存在未使用的函数参数，就跟使用命名参数一样。</p>
<p><strong>使用嵌套的 _ 忽略部分值</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">setting_value</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">new_setting_value</span> = <span class="title function_ invoke__">Some</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">match</span> (setting_value, new_setting_value) &#123;</span><br><span class="line">        (<span class="title function_ invoke__">Some</span>(_), <span class="title function_ invoke__">Some</span>(_)) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Can&#x27;t overwrite an existing customized value&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt; &#123;</span><br><span class="line">            setting_value = new_setting_value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>也可以在一个模式中的多处使用下划线来忽略特定值</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> numbers &#123;</span><br><span class="line">       (first, _, third, _, fifth) =&gt; &#123;</span><br><span class="line">           <span class="built_in">println!</span>(<span class="string">&quot;Some numbers: &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, first, third, fifth)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p><strong>通过在名字前以一个下划线开头来忽略未使用的变量</strong></p>
<p>只使用 <code>_</code> 和使用以下划线开头的名称有些微妙的不同：比如 <code>_x</code> 仍会将值绑定到变量，而 <code>_</code> 则完全不会绑定。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">Some</span>(String::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello!&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(_s) = s &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;found a string&quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, s);<span class="comment">// error! 因为 s 的值仍然会移动进 _s</span></span><br></pre></td></tr></table></figure>



<p><strong>用 .. 忽略剩余值</strong></p>
<p>对于有多个部分的值，可以使用 <code>..</code> 语法来只使用部分并忽略其它值，同时避免不得不每一个忽略值列出下划线。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span>,</span><br><span class="line">    z: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">origin</span> = Point &#123; x: <span class="number">0</span>, y: <span class="number">0</span>, z: <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> origin &#123;</span><br><span class="line">    Point &#123; x, .. &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;x is &#123;&#125;&quot;</span>, x),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不得不列出 <code>y: _</code> 和 <code>z: _</code> 要来得简单</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">numbers</span> = (<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> numbers &#123;</span><br><span class="line">    (first, .., last) =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Some numbers: &#123;&#125;, &#123;&#125;&quot;</span>, first, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而使用 <code>..</code> 必须是无歧义的。如果期望匹配和忽略的值是不明确的，Rust 会报错。 </p>
<p>比如，不能<code>(.., second, ..)</code></p>
<h4 id="匹配守卫提供的额外条件"><a href="#匹配守卫提供的额外条件" class="headerlink" title="匹配守卫提供的额外条件"></a>匹配守卫提供的额外条件</h4><p><strong>匹配守卫</strong>（<em>match guard</em>）是一个指定于 <code>match</code> 分支模式之后的额外 <code>if</code> 条件，它也必须被满足才能选择此分支。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">num</span> = <span class="title function_ invoke__">Some</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> num &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(x) <span class="keyword">if</span> x &lt; <span class="number">5</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;less than five: &#123;&#125;&quot;</span>, x),</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(x) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x),</span><br><span class="line">    <span class="literal">None</span> =&gt; (),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这种额外表现力的缺点在于当涉及匹配守卫表达式时编译器不会尝试检查穷尽性。</p>
<p>可以使用匹配守卫来解决模式中变量覆盖的问题</p>
<p>可以在匹配守卫中使用 <strong>或</strong> 运算符 <code>|</code> 来指定多个模式</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> x &#123;</span><br><span class="line">    <span class="number">4</span> | <span class="number">5</span> | <span class="number">6</span> <span class="keyword">if</span> y =&gt; <span class="built_in">println!</span>(<span class="string">&quot;yes&quot;</span>),</span><br><span class="line">    _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;no&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个匹配条件表明此分支值匹配 <code>x</code> 值为 <code>4</code>、<code>5</code> 或 <code>6</code> <strong>同时</strong> <code>y</code> 为 <code>true</code> 的情况。</p>
<p>匹配守卫与模式的优先级关系看起来像这样：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(4 | 5 | 6) if y =&gt; ...</span><br></pre></td></tr></table></figure>



<h4 id="绑定"><a href="#绑定" class="headerlink" title="@ 绑定"></a>@ 绑定</h4><p><em>at</em> 运算符（<code>@</code>）允许我们在创建一个存放值的变量的同时测试其值是否匹配模式。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">       Hello &#123; id: <span class="type">i32</span> &#125;,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">msg</span> = Message::Hello &#123; id: <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">match</span> msg &#123;</span><br><span class="line">       Message::Hello &#123;</span><br><span class="line">           id: id_variable @ <span class="number">3</span>..=<span class="number">7</span>,</span><br><span class="line">       &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Found an id in range: &#123;&#125;&quot;</span>, id_variable),</span><br><span class="line">       Message::Hello &#123; id: <span class="number">10</span>..=<span class="number">12</span> &#125; =&gt; &#123;</span><br><span class="line">           <span class="built_in">println!</span>(<span class="string">&quot;Found an id in another range&quot;</span>)</span><br><span class="line">       &#125;</span><br><span class="line">       Message::Hello &#123; id &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Found some other id: &#123;&#125;&quot;</span>, id),</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>通过在 <code>3..=7</code> 之前指定 <code>id_variable @</code>，我们捕获了任何匹配此范围的值并同时测试其值匹配这个范围模式。</p>
<p>使用 <code>@</code> 可以在一个模式中同时测试和保存变量值</p>
<p>&#x2F;&#x2F; 没有理解用途</p>
<h2 id="高级特征"><a href="#高级特征" class="headerlink" title="高级特征"></a>高级特征</h2><ul>
<li>不安全 Rust：用于当需要舍弃 Rust 的某些保证并负责手动维持这些保证</li>
<li>高级 trait：与 trait 相关的关联类型，默认类型参数，完全限定语法（fully qualified syntax），超（父）trait（supertraits）和 newtype 模式</li>
<li>高级类型：关于 newtype 模式的更多内容，类型别名，never 类型和动态大小类型</li>
<li>高级函数和闭包：函数指针和返回闭包</li>
<li>宏：定义在编译时定义更多代码的方式</li>
</ul>
<h3 id="不安全-Rust"><a href="#不安全-Rust" class="headerlink" title="不安全 Rust"></a>不安全 Rust</h3><p>原因:</p>
<ol>
<li><p>不安全 Rust 之所以存在，是因为静态分析本质上是保守的。这必然意味着有时代码 <strong>可能</strong> 是合法的，但如果 Rust 编译器没有足够的信息来确定，它将拒绝该代码。</p>
</li>
<li><p>底层计算机硬件固有的不安全性。如果 Rust 不允许进行不安全操作，那么有些任务则根本完成不了。</p>
</li>
</ol>
<p>不安全的超能力。” 这些超能力是：</p>
<ul>
<li>解引用裸指针</li>
<li>调用不安全的函数或方法</li>
<li>访问或修改可变静态变量</li>
<li>实现不安全 trait</li>
<li>访问 <code>union</code> 的字段</li>
</ul>
<h4 id="解引用裸指针"><a href="#解引用裸指针" class="headerlink" title="解引用裸指针"></a>解引用裸指针</h4><p><strong>裸指针</strong>与引用和智能指针的区别在于</p>
<ul>
<li>允许忽略借用规则，可以同时拥有不可变和可变的指针，或多个指向相同位置的可变指针</li>
<li>不保证指向有效的内存</li>
<li>允许为空</li>
<li>不能实现任何自动清理功能</li>
</ul>
<p>裸指针是不可变或可变的，分别写作 <code>*const T</code> 和 <code>*mut T</code>。这里的星号不是解引用运算符；它是类型名称的一部分。</p>
<p>创建一个指针不会造成任何危险；只有当访问其指向的值时才有可能遇到无效的值。</p>
<p>解引用裸指针必须在 unsafe块内</p>
<h4 id="调用不安全的函数或方法"><a href="#调用不安全的函数或方法" class="headerlink" title="调用不安全的函数或方法"></a>调用不安全的函数或方法</h4><p>在此上下文中，关键字<code>unsafe</code>表示该函数具有调用时需要满足的要求，而 Rust 不会保证满足这些要求。通过在 <code>unsafe</code> 块中调用不安全函数，表明我们已经阅读过此函数的文档并对其是否满足函数自身的契约负责。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">dangerous</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">dangerous</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不安全函数体也是有效的 <code>unsafe</code> 块，所以在不安全函数中进行另一个不安全操作时无需新增额外的 <code>unsafe</code> 块。</p>
<p>事实上，将不安全代码封装进安全函数是一个常见的抽象。</p>
<p>使用 extern 函数调用外部代码，<code>&quot;C&quot;</code> 部分定义了外部函数所使用的 <strong>应用二进制接口</strong>（<em>application binary interface</em>，ABI） </p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">abs</span>(input: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Absolute value of -3 according to C: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">abs</span>(-<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>从其它语言调用 Rust 函数，需要添加<code>#[no_mangle]</code> 注解，来告诉 Rust 编译器不要 mangle 此函数的名称。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="meta">#[no_mangle]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">call_from_c</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Just called a Rust function from C!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="访问或修改可变静态变量"><a href="#访问或修改可变静态变量" class="headerlink" title="访问或修改可变静态变量"></a>访问或修改可变静态变量</h4><p>全局变量在 Rust 中被称为 <strong>静态</strong>（<em>static</em>）变量。</p>
<p>通常静态变量的名称采用 <code>SCREAMING_SNAKE_CASE</code> 写法。静态变量只能储存拥有 <code>&#39;static</code> 生命周期的引用，这意味着 Rust 编译器可以自己计算出其生命周期而无需显式标注。访问不可变静态变量是安全的。</p>
<p>常量与不可变静态变量可能看起来很类似，不过一个微妙的区别是<code>静态变量</code>中的值有一个<strong>固定的内存地址</strong>。使用这个值总是会访问相同的地址。另一方面，<code>常量</code>则允许在任何被用到的时候<strong>复制其数据</strong>。</p>
<p>访问和修改可变静态变量都是 <strong>不安全</strong> 的。</p>
<p>优先使用并发技术和线程安全智能指针</p>
<h4 id="实现不安全-trait"><a href="#实现不安全-trait" class="headerlink" title="实现不安全 trait"></a>实现不安全 trait</h4><p>当 trait 中至少有一个方法中包含编译器无法验证的不变式（invariant）时 trait 是不安全的。可以在 <code>trait</code> 之前增加 <code>unsafe</code> 关键字将 trait 声明为 <code>unsafe</code>，同时 trait 的实现也必须标记为 <code>unsafe</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="keyword">trait</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="comment">// methods go here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span> <span class="title class_">Foo</span> <span class="keyword">for</span> <span class="title class_">i32</span> &#123;</span><br><span class="line">    <span class="comment">// method implementations go here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>编译器会自动为完全由 <code>Send</code> 和 <code>Sync</code> 类型组成的类型自动实现他们。如果实现了一个包含一些不是 <code>Send</code> 或 <code>Sync</code> 的类型，比如裸指针，并希望将此类型标记为 <code>Send</code> 或 <code>Sync</code>，则必须使用 <code>unsafe</code>。</p>
<p>Rust 不能验证我们的类型保证可以安全的跨线程发送或在多线程间访问，所以需要我们自己进行检查并通过 <code>unsafe</code> 表明</p>
<h4 id="访问联合体中的字段"><a href="#访问联合体中的字段" class="headerlink" title="访问联合体中的字段"></a>访问联合体中的字段</h4><p><code>union</code> 和 <code>struct</code> 类似，但是在一个实例中同时只能使用一个声明的字段。联合体主要用于和 C 代码中的联合体交互。</p>
<p>访问联合体的字段是不安全的，因为 Rust 无法保证当前存储在联合体实例中数据的类型。</p>
<h3 id="高级-trait"><a href="#高级-trait" class="headerlink" title="高级 trait"></a>高级 trait</h3><h4 id="关联类型在-trait-定义中指定占位符类型"><a href="#关联类型在-trait-定义中指定占位符类型" class="headerlink" title="关联类型在 trait 定义中指定占位符类型"></a>关联类型在 trait 定义中指定占位符类型</h4><p><strong>关联类型</strong>（<em>associated types</em>）是一个将类型占位符与 trait 相关联的方式，这样 trait 的方法签名中就可以使用这些占位符类型。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    count: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> Counter &#123;</span><br><span class="line">        Counter &#123; count: <span class="number">0</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Iterator</span> <span class="keyword">for</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span> = <span class="type">u32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt; &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.count &lt; <span class="number">5</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.count += <span class="number">1</span>;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(<span class="keyword">self</span>.count)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="literal">None</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2022/07/22/%5B%E5%A4%87%E5%BF%98%E5%BD%95%5D%5BRust%5D/image-20220815151144403.png" alt="image-20220815151144403"></p>
<h4 id="默认泛型类型参数和运算符重载"><a href="#默认泛型类型参数和运算符重载" class="headerlink" title="默认泛型类型参数和运算符重载"></a>默认泛型类型参数和运算符重载</h4><p>如果默认类型就足够的话，这消除了为具体类型实现 trait 的需要。为泛型类型指定默认类型的语法是在声明泛型类型时使用 <code>&lt;PlaceholderType=ConcreteType&gt;</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Add</span>&lt;Rhs=<span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, rhs: Rhs) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比较陌生的部分是尖括号中的 <code>Rhs=Self</code>：这个语法叫做 <strong>默认类型参数</strong>（<em>default type parameters</em>）。<code>Rhs</code> 是一个泛型类型参数（“right hand side” 的缩写），它用于定义 <code>add</code> 方法中的 <code>rhs</code> 参数。如果实现 <code>Add</code> trait 时不指定 <code>Rhs</code> 的具体类型，<code>Rhs</code> 的类型将是默认的 <code>Self</code> 类型，也就是在其上实现 <code>Add</code> 的类型。</p>
<p>我们指定 <code>impl Add&lt;Meters&gt;</code> 来设定 <code>Rhs</code> 类型参数的值而不是使用默认的 <code>Self</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Add;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Millimeters</span>(<span class="type">u32</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Meters</span>(<span class="type">u32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Add</span>&lt;Meters&gt; <span class="keyword">for</span> <span class="title class_">Millimeters</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = Millimeters;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, other: Meters) <span class="punctuation">-&gt;</span> Millimeters &#123;</span><br><span class="line">        <span class="title function_ invoke__">Millimeters</span>(<span class="keyword">self</span>.<span class="number">0</span> + (other.<span class="number">0</span> * <span class="number">1000</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="完全限定语法与消歧义：调用相同名称的方法"><a href="#完全限定语法与消歧义：调用相同名称的方法" class="headerlink" title="完全限定语法与消歧义：调用相同名称的方法"></a>完全限定语法与消歧义：调用相同名称的方法</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">person</span> = Human;</span><br><span class="line">    Pilot::<span class="title function_ invoke__">fly</span>(&amp;person);</span><br><span class="line">    Wizard::<span class="title function_ invoke__">fly</span>(&amp;person);</span><br><span class="line">    person.<span class="title function_ invoke__">fly</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Type <span class="keyword">as</span> Trait&gt;::<span class="title function_ invoke__">function</span>(receiver_if_method, next_arg, ...);</span><br></pre></td></tr></table></figure>

<h4 id="父-trait-用于在另一个-trait-中使用某-trait-的功能"><a href="#父-trait-用于在另一个-trait-中使用某-trait-的功能" class="headerlink" title="父 trait 用于在另一个 trait 中使用某 trait 的功能"></a>父 trait 用于在另一个 trait 中使用某 trait 的功能</h4><p>有时我们可能会需要某个 trait 使用另一个 trait 的功能。在这种情况下，需要能够依赖相关的 trait 也被实现。这个所需的 trait 是我们实现的 trait 的 <strong>父（超） trait</strong>（<em>supertrait</em>）。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">OutlinePrint</span>: fmt::Display &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">outline_print</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">       <span class="comment">// -- snip code --</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="newtype-模式用以在外部类型上实现外部-trait"><a href="#newtype-模式用以在外部类型上实现外部-trait" class="headerlink" title="newtype 模式用以在外部类型上实现外部 trait"></a>newtype 模式用以在外部类型上实现外部 trait</h4><p>孤儿规则（orphan rule），它说明只要 trait 或类型对于当前 crate 是本地的话就可以在此类型上实现该 trait。</p>
<p>一个绕开这个限制的方法是使用 <strong>newtype 模式</strong>（<em>newtype pattern</em>），它涉及到在一个元组结构体中创建一个新类型。这个元组结构体带有一个字段作为希望实现 trait 的类型的简单封装。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Wrapper</span>(<span class="type">Vec</span>&lt;<span class="type">String</span>&gt;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">Wrapper</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;[&#123;&#125;]&quot;</span>, <span class="keyword">self</span>.<span class="number">0</span>.<span class="title function_ invoke__">join</span>(<span class="string">&quot;, &quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">w</span> = <span class="title function_ invoke__">Wrapper</span>(<span class="built_in">vec!</span>[String::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>), String::<span class="title function_ invoke__">from</span>(<span class="string">&quot;world&quot;</span>)]);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;w = &#123;&#125;&quot;</span>, w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此方法的缺点是，因为 <code>Wrapper</code> 是一个新类型，它没有定义于其值之上的方法；必须直接在 <code>Wrapper</code> 上实现 <code>Vec&lt;T&gt;</code> 的所有方法，这样就可以代理到<code>self.0</code> 上 </p>
<p>如果不希望封装类型拥有所有内部类型的方法 —— 比如为了限制封装类型的行为 —— 则必须只自行实现所需的方法。</p>
<h3 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h3><p><strong>包括静态的确保某值不被混淆，和用来表示一个值的单位,。</strong></p>
<p><code>Millimeters</code> 和 <code>Meters</code> 结构体都在 newtype 中封装了 <code>u32</code> 值。如果编写了一个有 <code>Millimeters</code> 类型参数的函数，不小心使用 <code>Meters</code> 或普通的 <code>u32</code> 值来调用该函数的程序是不能编译的。</p>
<p><strong>抽象掉一些类型的实现细节</strong></p>
<p>例如，可以提供一个封装了 <code>HashMap&lt;i32, String&gt;</code> 的 <code>People</code> 类型，用来储存人名以及相应的 ID。使用 <code>People</code> 的代码只需与提供的公有 API 交互即可，比如向 <code>People</code> 集合增加名字字符串的方法，这样这些代码就无需知道在内部我们将一个 <code>i32</code> ID 赋予了这个名字了。</p>
<h4 id="类型别名用来创建类型同义词"><a href="#类型别名用来创建类型同义词" class="headerlink" title="类型别名用来创建类型同义词"></a>类型别名用来创建类型同义词</h4><p>Rust 还提供了声明 <strong>类型别名</strong>（<em>type alias</em>）的能力，使用 <code>type</code> 关键字来给予现有类型另一个名字。例如，可以像这样创建 <code>i32</code> 的别名 <code>Kilometers</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Kilometers</span> = <span class="type">i32</span>;</span><br></pre></td></tr></table></figure>



<p>类型别名通过减少项目中重复代码的数量来使其更加易于控制。</p>
<p>类型别名也经常与 <code>Result&lt;T, E&gt;</code> 结合使用来减少重复。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span>&lt;T&gt; = std::result::<span class="type">Result</span>&lt;T, std::io::Error&gt;;</span><br></pre></td></tr></table></figure>



<h4 id="从不返回的-never-type"><a href="#从不返回的-never-type" class="headerlink" title="从不返回的 never type"></a>从不返回的 never type</h4><p>Rust 有一个叫做 <code>!</code> 的特殊类型。在类型理论术语中，它被称为 <em>empty type</em>，因为它没有值。我们更倾向于称之为 <em>never type</em>。这个名字描述了它的作用：在函数从不返回的时候充当返回值。例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">bar</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而从不返回的函数被称为 <strong>发散函数</strong>（<em>diverging functions</em>）</p>
<p>正如你可能猜到的，<code>continue</code> 的值是 <code>!</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">guess</span>: <span class="type">u32</span> = <span class="keyword">match</span> guess.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(num) =&gt; num,</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(_) =&gt; <span class="keyword">continue</span>,</span><br><span class="line">       &#125;;</span><br></pre></td></tr></table></figure>

<p>never type 的另一个用途是 <code>panic!</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="type">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">unwrap</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(val) =&gt; val,</span><br><span class="line">            <span class="literal">None</span> =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;called `Option::unwrap()` on a `None` value&quot;</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后一个有着 <code>!</code> 类型的表达式是 <code>loop</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;forever &quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">loop</span> &#123;</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">&quot;and ever &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="动态大小类型和-Sized-trait"><a href="#动态大小类型和-Sized-trait" class="headerlink" title="动态大小类型和 Sized trait"></a>动态大小类型和 Sized trait</h4><p>因为 Rust 需要知道例如应该为特定类型的值分配多少空间这样的信息</p>
<p>这就是 <strong>动态大小类型</strong>（<em>dynamically sized types</em>）的概念。这有时被称为 “DST” 或 “unsized types”</p>
<p><code>str</code> 是一个 DST；直到运行时我们都不知道字符串有多长。因为直到运行时都不能知道其大小，也就意味着不能创建 <code>str</code> 类型的变量，也不能获取 <code>str</code> 类型的参数。</p>
<p>Rust 需要知道应该为特定类型的值分配多少内存，同时所有同一类型的值必须使用相同数量的内存。</p>
<p><code>&amp;str</code> 则是 <strong>两个</strong> 值：<code>str</code> 的地址和其长度。这样，<code>&amp;str</code> 就有了一个在编译时可以知道的大小：它是 <code>usize</code> 长度的两倍。</p>
<p>们有一些额外的元信息来储存动态信息的大小。这引出了动态大小类型的黄金规则：<strong>必须将动态大小类型的值置于某种指针之后。</strong></p>
<p>另一个动态大小类型：trait。每一个 trait 都是一个可以通过 trait 名称来引用的动态大小类型。</p>
<p>我们提到了为了将 trait 用于 trait 对象，必须将他们放入指针之后，比如 <code>&amp;dyn Trait</code> 或 <code>Box&lt;dyn Trait&gt;</code></p>
<p>为了处理 DST，Rust 有一个特定的 trait 来决定一个类型的大小是否在编译时可知：这就是 <code>Sized</code> trait。</p>
<p>另外，Rust 隐式的为每一个泛型函数增加了 <code>Sized</code> bound。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">generic</span>&lt;T&gt;(t: T) &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上被当作如下处理：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">generic</span>&lt;T: <span class="built_in">Sized</span>&gt;(t: T) &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>泛型函数默认只能用于在编译时已知大小的类型。然而可以使用如下特殊语法来放宽这个限制：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">generic</span>&lt;T: ?<span class="built_in">Sized</span>&gt;(t: &amp;T) &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>?Sized</code> 上的 trait bound 意味着 “<code>T</code> 可能是也可能不是 <code>Sized</code>” 。这种意义的 <code>?Trait</code> 语法只能用于 <code>Sized</code> ，而不能用于任何其他 trait。</p>
<p>另外注意我们将 <code>t</code> 参数的类型从 <code>T</code> 变为了 <code>&amp;T</code>：因为其类型可能不是 <code>Sized</code> 的，所以需要将其置于某种指针之后。在这个例子中选择了引用。</p>
<h3 id="高级函数与闭包"><a href="#高级函数与闭包" class="headerlink" title="高级函数与闭包"></a>高级函数与闭包</h3><p>我们讨论过了如何向函数传递闭包；也可以向函数传递常规函数！</p>
<p>通过函数指针允许我们使用函数作为另一个函数的参数。函数的类型是 <code>fn</code> </p>
<p><code>fn</code> 被称为 <strong>函数指针</strong>（<em>function pointer</em>）。指定参数为函数指针的语法类似于闭包</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">add_one</span>(x: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    x + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">do_twice</span>(f: <span class="title function_ invoke__">fn</span>(<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span>, arg: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">f</span>(arg) + <span class="title function_ invoke__">f</span>(arg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">answer</span> = <span class="title function_ invoke__">do_twice</span>(add_one, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The answer is: &#123;&#125;&quot;</span>, answer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不同于闭包，<code>fn</code> 是一个类型而不是一个 trait，所以直接指定 <code>fn</code> 作为参数而不是声明一个带有 <code>Fn</code> 作为 trait bound 的泛型参数。</p>
<p>函数指针实现了所有三个闭包 trait（<code>Fn</code>、<code>FnMut</code> 和 <code>FnOnce</code>），所以总是可以在调用期望闭包的函数时传递函数指针作为参数。</p>
<p>一个只期望接受 <code>fn</code> 而不接受闭包的情况的例子是与不存在闭包的外部代码交互时：C 语言的函数可以接受函数作为参数，但 C 语言没有闭包。</p>
<p>作为一个既可以使用内联定义的闭包又可以使用命名函数的例子，让我们看看一个 <code>map</code> 的应用。使用 <code>map</code> 函数将一个数字 vector 转换为一个字符串 vector，就可以使用闭包，比如这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">list_of_numbers</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">list_of_strings</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; =</span><br><span class="line">    list_of_numbers.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">map</span>(|i| i.<span class="title function_ invoke__">to_string</span>()).<span class="title function_ invoke__">collect</span>();</span><br></pre></td></tr></table></figure>

<p>或者可以将函数作为 <code>map</code> 的参数来代替闭包，像是这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">list_of_numbers</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">list_of_strings</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; =</span><br><span class="line">    list_of_numbers.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">map</span>(<span class="built_in">ToString</span>::to_string).<span class="title function_ invoke__">collect</span>();</span><br></pre></td></tr></table></figure>

<p>注意这里必须使用 <a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch19-03-advanced-traits.html#%E9%AB%98%E7%BA%A7-trait">“高级 trait”</a> 部分讲到的完全限定语法，因为存在多个叫做 <code>to_string</code> 的函数；这里使用了定义于 <code>ToString</code> trait 的 <code>to_string</code> 函数</p>
<p>另一个实用的模式暴露了元组结构体和元组结构体枚举成员的实现细节。这些项使用 <code>()</code> 作为初始化语法，这看起来就像函数调用，同时它们确实被<strong>实现为返回由参数构造的实例的函数</strong>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">enum</span> <span class="title class_">Status</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Value</span>(<span class="type">u32</span>),</span><br><span class="line">        Stop,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">list_of_statuses</span>: <span class="type">Vec</span>&lt;Status&gt; = (<span class="number">0u32</span>..<span class="number">20</span>).<span class="title function_ invoke__">map</span>(Status::Value).<span class="title function_ invoke__">collect</span>();</span><br></pre></td></tr></table></figure>



<h4 id="返回闭包"><a href="#返回闭包" class="headerlink" title="返回闭包"></a>返回闭包</h4><p>闭包表现为 trait，这意味着不能直接返回闭包。</p>
<p>错误又一次指向了 <code>Sized</code> trait！Rust 并不知道需要多少空间来储存闭包。不过我们在上一部分见过这种情况的解决办法：可以使用 trait 对象：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">returns_closure</span>() <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> <span class="title function_ invoke__">Fn</span>(<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span>&gt; &#123;</span><br><span class="line">    Box::<span class="title function_ invoke__">new</span>(|x| x + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><p><strong>宏</strong>（<em>Macro</em>）指的是 Rust 中一系列的功能：</p>
<p>使用 <code>macro_rules!</code> 的 <strong>声明</strong>（<em>Declarative</em>）宏，和三种 <strong>过程</strong>（<em>Procedural</em>）宏：</p>
<ul>
<li>自定义 <code>#[derive]</code> 宏在结构体和枚举上指定通过 <code>derive</code> 属性添加的代码</li>
<li>类属性（Attribute-like）宏定义可用于任意项的自定义属性</li>
<li>类函数宏看起来像函数不过作用于作为参数传递的 token</li>
</ul>
<h4 id="宏和函数的区别"><a href="#宏和函数的区别" class="headerlink" title="宏和函数的区别"></a>宏和函数的区别</h4><p>从根本上来说，宏是一种为写其他代码而写代码的方式，即所谓的 <strong>元编程</strong>（<em>metaprogramming</em>）。</p>
<p>一个函数签名必须声明函数参数个数和类型。相比之下，宏能够接收不同数量的参数</p>
<p>宏可以在编译器翻译代码前展开</p>
<p>实现宏不如实现函数的一面是宏定义要比函数定义更复杂，因为你正在编写生成 Rust 代码的 Rust 代码。由于这样的间接性，宏定义通常要比函数定义更难阅读、理解以及维护。</p>
<p>在一个文件里调用宏 <strong>之前</strong> 必须定义它，或将其引入作用域，而函数则可以在任何地方定义和调用。</p>
<h4 id="使用-macro-rules-的声明宏用于通用元编程"><a href="#使用-macro-rules-的声明宏用于通用元编程" class="headerlink" title="使用 macro_rules! 的声明宏用于通用元编程"></a>使用 macro_rules! 的声明宏用于通用元编程</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> vec &#123;</span><br><span class="line">    ( $( $x:expr ),* ) =&gt; &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">temp_vec</span> = Vec::<span class="title function_ invoke__">new</span>();</span><br><span class="line">            $(</span><br><span class="line">                temp_vec.<span class="title function_ invoke__">push</span>($x);</span><br><span class="line">            )*</span><br><span class="line">            temp_vec</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">temp_vec</span> = Vec::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    temp_vec.<span class="title function_ invoke__">push</span>(<span class="number">1</span>);</span><br><span class="line">    temp_vec.<span class="title function_ invoke__">push</span>(<span class="number">2</span>);</span><br><span class="line">    temp_vec.<span class="title function_ invoke__">push</span>(<span class="number">3</span>);</span><br><span class="line">    temp_vec</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>#[macro_export]</code> 注解表明只要导入了定义这个宏的crate，该宏就应该是可用的。 如果没有该注解，这个宏不能被引入作用域。</p>
<p>接着使用 <code>macro_rules!</code> 和宏名称开始宏定义，且所定义的宏并 <strong>不带</strong> 感叹号。名字后跟大括号表示宏定义体，在该例中宏名称是 <code>vec</code></p>
<h4 id="用于从属性生成代码的过程宏"><a href="#用于从属性生成代码的过程宏" class="headerlink" title="用于从属性生成代码的过程宏"></a>用于从属性生成代码的过程宏</h4><p>它们更像函数（一种过程类型）</p>
<p>过程宏接收 Rust 代码作为输入，在这些代码上进行操作，然后产生另一些代码作为输出，而非像声明式宏那样匹配对应模式然后以另一部分代码替换当前代码。</p>
<p>有三种类型的过程宏（自定义派生（derive），类属性和类函数），不过它们的工作方式都类似。</p>
<p>创建过程宏时，其定义必须驻留在它们自己的具有特殊 crate 类型的 crate 中。这么做出于复杂的技术原因，将来我们希望能够消除这些限制。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> proc_macro;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[some_attribute]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">some_name</span>(input: TokenStream) <span class="punctuation">-&gt;</span> TokenStream &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>some_attribute</code> 是一个使用特定宏的占位符。</p>
<p>Rust默认携带了<code>proc_macro</code> crate。 这就是宏的核心：宏所处理的源代码组成了输入 <code>TokenStream</code>，宏生成的代码是输出 <code>TokenStream</code>。函数上还有一个属性；这个属性指明了我们创建的过程宏的类型。在同一 crate 中可以有多种的过程宏。</p>
<h4 id="类属性宏"><a href="#类属性宏" class="headerlink" title="类属性宏"></a>类属性宏</h4><p>不同的是 <code>derive</code> 属性生成代码，它们（类属性宏）能让你创建新的属性。</p>
<p>可以创建一个名为 <code>route</code> 的属性用于注解 web 应用程序框架（web application framework）的函数：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[route(GET, <span class="string">&quot;/&quot;</span>)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">index</span>() &#123; &#125;</span><br></pre></td></tr></table></figure>



<h4 id="类函数宏"><a href="#类函数宏" class="headerlink" title="类函数宏"></a>类函数宏</h4><p>类函数宏获取 <code>TokenStream</code> 参数，其定义使用 Rust 代码操纵 <code>TokenStream</code>，就像另两种过程宏一样。一个类函数宏例子是可以像这样被调用的 <code>sql!</code> 宏：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">sql</span> = sql!(SELECT * FROM posts WHERE id=<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" rel="tag"># 学习记录</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/07/16/%5B%E9%98%85%E8%AF%BB%5D%5B4%5D%E3%80%8A%E7%BD%AE%E8%BA%AB%E4%BA%8B%E5%86%85%E3%80%8B-%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/" rel="prev" title="《置身事内》阅读记录">
      <i class="fa fa-chevron-left"></i> 《置身事内》阅读记录
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/07/31/%5B%E7%AE%97%E6%B3%95%5D%5BKMP%5D/" rel="next" title="[算法][KMP]">
      [算法][KMP] <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2"><span class="nav-number">1.</span> <span class="nav-text">写在前面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Cargo-%E5%91%BD%E4%BB%A4"><span class="nav-number">2.</span> <span class="nav-text">Cargo 命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E8%A6%81%E7%89%B9%E7%82%B9"><span class="nav-number">3.</span> <span class="nav-text">重要特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%80%E6%9C%89%E6%9D%83%E8%A7%84%E5%88%99"><span class="nav-number">4.</span> <span class="nav-text">所有权规则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BA%A4%E4%BA%92%E8%A7%84%E5%88%99%EF%BC%9A%E7%A7%BB%E5%8A%A8-move"><span class="nav-number">4.1.</span> <span class="nav-text">变量与数据的交互规则：移动 move</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BA%A4%E4%BA%92%E8%A7%84%E5%88%99%EF%BC%9A%E5%85%8B%E9%9A%86-clone"><span class="nav-number">4.2.</span> <span class="nav-text">变量与数据的交互规则：克隆 clone</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AA%E5%9C%A8%E6%A0%88%E4%B8%8A%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%9A%E6%8B%B7%E8%B4%9D"><span class="nav-number">4.3.</span> <span class="nav-text">只在栈上的数据：拷贝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%80%E6%9C%89%E6%9D%83%E4%B8%8E%E5%87%BD%E6%95%B0"><span class="nav-number">4.4.</span> <span class="nav-text">所有权与函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">4.5.</span> <span class="nav-text">返回值与作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E4%B8%8E%E5%80%9F%E7%94%A8"><span class="nav-number">4.6.</span> <span class="nav-text">引用与借用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%87%E7%89%87"><span class="nav-number">4.7.</span> <span class="nav-text">切片</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">5.</span> <span class="nav-text">结构体</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95"><span class="nav-number">5.1.</span> <span class="nav-text">方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E8%81%94%E5%87%BD%E6%95%B0"><span class="nav-number">5.2.</span> <span class="nav-text">关联函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE"><span class="nav-number">6.</span> <span class="nav-text">枚举</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#match-%E6%8E%A7%E5%88%B6%E6%B5%81%E7%BB%93%E6%9E%84"><span class="nav-number">6.1.</span> <span class="nav-text">match 控制流结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%91%E5%AE%9A%E5%80%BC%E7%9A%84%E5%8C%B9%E9%85%8D"><span class="nav-number">6.1.1.</span> <span class="nav-text">绑定值的匹配</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#if-let%E7%AE%80%E6%B4%81%E6%8E%A7%E5%88%B6%E6%B5%81"><span class="nav-number">6.2.</span> <span class="nav-text">if let简洁控制流</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%85-crate%E5%92%8C%E6%A8%A1%E5%9D%97"><span class="nav-number">7.</span> <span class="nav-text">包 crate和模块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#pub-struct"><span class="nav-number">7.1.</span> <span class="nav-text">pub struct</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pub-enum"><span class="nav-number">7.2.</span> <span class="nav-text">pub enum</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#use"><span class="nav-number">7.3.</span> <span class="nav-text">use</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#as"><span class="nav-number">7.4.</span> <span class="nav-text">as</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pub-use"><span class="nav-number">7.5.</span> <span class="nav-text">pub use</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%A4%96%E9%83%A8%E5%8C%85"><span class="nav-number">7.6.</span> <span class="nav-text">使用外部包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%86%E5%88%86%E6%A8%A1%E5%9D%97%E4%B8%BA%E5%A4%9A%E4%B8%AA%E6%96%87%E4%BB%B6"><span class="nav-number">7.7.</span> <span class="nav-text">拆分模块为多个文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88"><span class="nav-number">8.</span> <span class="nav-text">常用集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#vector"><span class="nav-number">8.1.</span> <span class="nav-text">vector</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String"><span class="nav-number">8.2.</span> <span class="nav-text">String</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap"><span class="nav-number">8.3.</span> <span class="nav-text">HashMap</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="nav-number">9.</span> <span class="nav-text">错误处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E4%BC%A0%E6%92%AD"><span class="nav-number">9.1.</span> <span class="nav-text">错误传播</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B-trait-%E5%92%8C-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">10.</span> <span class="nav-text">泛型 trait 和 生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B"><span class="nav-number">10.1.</span> <span class="nav-text">泛型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tarit"><span class="nav-number">10.2.</span> <span class="nav-text">tarit</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#trait-%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0"><span class="nav-number">10.2.1.</span> <span class="nav-text">trait 作为参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E5%AE%9E%E7%8E%B0%E4%BA%86-trait-%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">10.2.2.</span> <span class="nav-text">返回实现了 trait 的类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-trait-bound-%E6%9C%89%E6%9D%A1%E4%BB%B6%E5%9C%B0%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="nav-number">10.2.3.</span> <span class="nav-text">使用 trait bound 有条件地实现方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">11.</span> <span class="nav-text">生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B3%A8%E8%A7%A3"><span class="nav-number">11.1.</span> <span class="nav-text">方法定义中的生命周期注解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95"><span class="nav-number">12.</span> <span class="nav-text">自动化测试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="nav-number">12.1.</span> <span class="nav-text">单元测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95"><span class="nav-number">12.2.</span> <span class="nav-text">集成测试</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6-crate-%E7%9A%84%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95"><span class="nav-number">12.2.1.</span> <span class="nav-text">二进制 crate 的集成测试</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AECLI"><span class="nav-number">13.</span> <span class="nav-text">项目CLI</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%EF%BC%8C%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E9%97%AD%E5%8C%85"><span class="nav-number">14.</span> <span class="nav-text">函数式编程，迭代器与闭包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AD%E5%8C%85"><span class="nav-number">14.1.</span> <span class="nav-text">闭包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">14.2.</span> <span class="nav-text">迭代器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%A7%E7%94%9F%E5%85%B6%E4%BB%96%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">14.2.1.</span> <span class="nav-text">产生其他迭代器的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-Iterator-trait-%E6%9D%A5%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">14.2.2.</span> <span class="nav-text">实现 Iterator trait 来创建自定义迭代器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cargo-%E4%B8%8E-crate-is"><span class="nav-number">15.</span> <span class="nav-text">cargo 与 crate.is</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#pub-use-1"><span class="nav-number">15.1.</span> <span class="nav-text">pub use</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%91%E5%B8%83%E5%88%B0-Crates-io"><span class="nav-number">15.2.</span> <span class="nav-text">发布到 Crates.io</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4"><span class="nav-number">15.3.</span> <span class="nav-text">工作空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8Ecrate-io-%E5%AE%89%E8%A3%85%E4%BA%8C%E8%BF%9B%E5%88%B6crate"><span class="nav-number">15.4.</span> <span class="nav-text">从crate.io 安装二进制crate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%91%BD%E4%BB%A4%E6%89%A9%E5%B1%95cargo"><span class="nav-number">15.5.</span> <span class="nav-text">自定义命令扩展cargo</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-number">16.</span> <span class="nav-text">智能指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Box-%E6%8C%87%E5%90%91%E5%A0%86%E4%B8%8A%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="nav-number">16.1.</span> <span class="nav-text">使用Box 指向堆上的数据</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Box-%E5%85%81%E8%AE%B8%E5%88%9B%E5%BB%BA%E9%80%92%E5%BD%92%E7%B1%BB%E5%9E%8B"><span class="nav-number">16.1.1.</span> <span class="nav-text">Box 允许创建递归类型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87-Deref-trait-%E5%B0%86%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%BD%93%E4%BD%9C%E5%B8%B8%E8%A7%84%E5%BC%95%E7%94%A8%E5%A4%84%E7%90%86"><span class="nav-number">16.2.</span> <span class="nav-text">通过 Deref trait 将智能指针当作常规引用处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E9%9A%90%E5%BC%8F-Deref-%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="nav-number">16.2.1.</span> <span class="nav-text">函数和方法的隐式 Deref 强制转换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Drop-Trait-%E8%BF%90%E8%A1%8C%E6%B8%85%E7%90%86%E4%BB%A3%E7%A0%81"><span class="nav-number">16.3.</span> <span class="nav-text">使用 Drop Trait 运行清理代码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87-std-mem-drop-%E6%8F%90%E6%97%A9%E4%B8%A2%E5%BC%83%E5%80%BC"><span class="nav-number">16.3.1.</span> <span class="nav-text">通过 std::mem::drop 提早丢弃值</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Rc-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-number">16.4.</span> <span class="nav-text">Rc 引用计数智能指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RefCell-%E5%92%8C%E5%86%85%E9%83%A8%E5%8F%AF%E5%8F%98%E6%80%A7%E6%A8%A1%E5%BC%8F"><span class="nav-number">16.5.</span> <span class="nav-text">RefCell 和内部可变性模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%86Rc-%E5%92%8C-RefCell%E7%BB%93%E5%90%88%E6%9D%A5%E6%8B%A5%E6%9C%89%E5%A4%9A%E4%B8%AA%E5%8F%AF%E5%8F%98%E6%95%B0%E6%8D%AE%E6%89%80%E6%9C%89%E8%80%85"><span class="nav-number">16.5.1.</span> <span class="nav-text">将Rc 和 RefCell结合来拥有多个可变数据所有者</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E5%AF%BC%E8%87%B4%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="nav-number">16.6.</span> <span class="nav-text">循环引用导致内存泄露</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E5%BC%95%E7%94%A8%E5%BE%AA%E7%8E%AF%EF%BC%9A%E5%B0%86-Rc-%E5%8F%98%E4%B8%BA-Weak"><span class="nav-number">16.6.1.</span> <span class="nav-text">避免引用循环：将 Rc 变为 Weak</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A0%E7%95%8F%E5%B9%B6%E5%8F%91"><span class="nav-number">17.</span> <span class="nav-text">无畏并发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8E-move-%E9%97%AD%E5%8C%85"><span class="nav-number">17.1.</span> <span class="nav-text">线程与 move 闭包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E5%9C%A8%E7%BA%BF%E7%A8%8B%E9%97%B4%E4%BC%A0%E9%80%81%E6%95%B0%E6%8D%AE"><span class="nav-number">17.2.</span> <span class="nav-text">使用消息传递在线程间传送数据</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E9%81%93%E4%B8%8E%E6%89%80%E6%9C%89%E6%9D%83%E8%BD%AC%E7%A7%BB"><span class="nav-number">17.2.1.</span> <span class="nav-text">信道与所有权转移</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E5%85%8B%E9%9A%86%E5%8F%91%E9%80%81%E8%80%85%E6%9D%A5%E5%88%9B%E5%BB%BA%E5%A4%9A%E4%B8%AA%E7%94%9F%E4%BA%A7%E8%80%85"><span class="nav-number">17.2.2.</span> <span class="nav-text">通过克隆发送者来创建多个生产者</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E7%8A%B6%E6%80%81%E5%B9%B6%E5%8F%91"><span class="nav-number">17.3.</span> <span class="nav-text">共享状态并发</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%85%B1%E4%BA%AB-Mutex"><span class="nav-number">17.3.1.</span> <span class="nav-text">在线程间共享 Mutex</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0-Arc"><span class="nav-number">17.3.1.1.</span> <span class="nav-text">原子引用计数 Arc</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Sync-%E5%92%8C-Send-trait-%E7%9A%84%E5%8F%AF%E6%89%A9%E5%B1%95%E5%B9%B6%E5%8F%91"><span class="nav-number">17.4.</span> <span class="nav-text">使用 Sync 和 Send trait 的可扩展并发</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Rust-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BC%96%E7%A8%8B%E7%89%B9%E6%80%A7"><span class="nav-number">18.</span> <span class="nav-text">Rust 面向对象 编程特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%8C%85%E5%90%AB%E6%95%B0%E6%8D%AE%E5%92%8C%E8%A1%8C%E4%B8%BA"><span class="nav-number">18.1.</span> <span class="nav-text">对象包含数据和行为</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%81%E8%A3%85%E9%9A%90%E8%97%8F%E4%BA%86%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="nav-number">18.2.</span> <span class="nav-text">封装隐藏了实现细节</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%EF%BC%8C%E4%BD%9C%E4%B8%BA%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E4%B8%8E%E4%BB%A3%E7%A0%81%E5%85%B1%E4%BA%AB"><span class="nav-number">18.3.</span> <span class="nav-text">继承，作为类型系统与代码共享</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">18.4.</span> <span class="nav-text">面向对象设计模式的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="nav-number">19.</span> <span class="nav-text">模式与模式匹配</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Refutability%EF%BC%88%E5%8F%AF%E5%8F%8D%E9%A9%B3%E6%80%A7%EF%BC%89-%E6%A8%A1%E5%BC%8F%E6%98%AF%E5%90%A6%E4%BC%9A%E5%8C%B9%E9%85%8D%E5%A4%B1%E6%95%88"><span class="nav-number">19.1.</span> <span class="nav-text">Refutability（可反驳性）: 模式是否会匹配失效</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%80%E6%9C%89%E7%9A%84%E6%A8%A1%E5%BC%8F%E8%AF%AD%E6%B3%95"><span class="nav-number">19.2.</span> <span class="nav-text">所有的模式语法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87-x3D-%E5%8C%B9%E9%85%8D%E5%80%BC%E7%9A%84%E8%8C%83%E5%9B%B4"><span class="nav-number">19.2.1.</span> <span class="nav-text">通过 ..&#x3D; 匹配值的范围</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E6%9E%84%E5%B9%B6%E5%88%86%E8%A7%A3%E5%80%BC"><span class="nav-number">19.2.2.</span> <span class="nav-text">解构并分解值</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E6%9E%84%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">19.2.2.1.</span> <span class="nav-text">解构结构体</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E6%9E%84%E6%9E%9A%E4%B8%BE"><span class="nav-number">19.2.2.2.</span> <span class="nav-text">解构枚举</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E6%9E%84%E5%B5%8C%E5%A5%97%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E6%9E%9A%E4%B8%BE"><span class="nav-number">19.2.2.3.</span> <span class="nav-text">解构嵌套的结构体和枚举</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E6%9E%84%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E5%85%83%E7%BB%84"><span class="nav-number">19.2.2.4.</span> <span class="nav-text">解构结构体和元组</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%BD%E7%95%A5%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E5%80%BC"><span class="nav-number">19.2.3.</span> <span class="nav-text">忽略模式中的值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%B9%E9%85%8D%E5%AE%88%E5%8D%AB%E6%8F%90%E4%BE%9B%E7%9A%84%E9%A2%9D%E5%A4%96%E6%9D%A1%E4%BB%B6"><span class="nav-number">19.2.4.</span> <span class="nav-text">匹配守卫提供的额外条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%91%E5%AE%9A"><span class="nav-number">19.2.5.</span> <span class="nav-text">@ 绑定</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E7%89%B9%E5%BE%81"><span class="nav-number">20.</span> <span class="nav-text">高级特征</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E5%AE%89%E5%85%A8-Rust"><span class="nav-number">20.1.</span> <span class="nav-text">不安全 Rust</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E5%BC%95%E7%94%A8%E8%A3%B8%E6%8C%87%E9%92%88"><span class="nav-number">20.1.1.</span> <span class="nav-text">解引用裸指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E5%87%BD%E6%95%B0%E6%88%96%E6%96%B9%E6%B3%95"><span class="nav-number">20.1.2.</span> <span class="nav-text">调用不安全的函数或方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%88%96%E4%BF%AE%E6%94%B9%E5%8F%AF%E5%8F%98%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="nav-number">20.1.3.</span> <span class="nav-text">访问或修改可变静态变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%8D%E5%AE%89%E5%85%A8-trait"><span class="nav-number">20.1.4.</span> <span class="nav-text">实现不安全 trait</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E8%81%94%E5%90%88%E4%BD%93%E4%B8%AD%E7%9A%84%E5%AD%97%E6%AE%B5"><span class="nav-number">20.1.5.</span> <span class="nav-text">访问联合体中的字段</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7-trait"><span class="nav-number">20.2.</span> <span class="nav-text">高级 trait</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E8%81%94%E7%B1%BB%E5%9E%8B%E5%9C%A8-trait-%E5%AE%9A%E4%B9%89%E4%B8%AD%E6%8C%87%E5%AE%9A%E5%8D%A0%E4%BD%8D%E7%AC%A6%E7%B1%BB%E5%9E%8B"><span class="nav-number">20.2.1.</span> <span class="nav-text">关联类型在 trait 定义中指定占位符类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">20.2.2.</span> <span class="nav-text">默认泛型类型参数和运算符重载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E9%99%90%E5%AE%9A%E8%AF%AD%E6%B3%95%E4%B8%8E%E6%B6%88%E6%AD%A7%E4%B9%89%EF%BC%9A%E8%B0%83%E7%94%A8%E7%9B%B8%E5%90%8C%E5%90%8D%E7%A7%B0%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">20.2.3.</span> <span class="nav-text">完全限定语法与消歧义：调用相同名称的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%88%B6-trait-%E7%94%A8%E4%BA%8E%E5%9C%A8%E5%8F%A6%E4%B8%80%E4%B8%AA-trait-%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%9F%90-trait-%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="nav-number">20.2.4.</span> <span class="nav-text">父 trait 用于在另一个 trait 中使用某 trait 的功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#newtype-%E6%A8%A1%E5%BC%8F%E7%94%A8%E4%BB%A5%E5%9C%A8%E5%A4%96%E9%83%A8%E7%B1%BB%E5%9E%8B%E4%B8%8A%E5%AE%9E%E7%8E%B0%E5%A4%96%E9%83%A8-trait"><span class="nav-number">20.2.5.</span> <span class="nav-text">newtype 模式用以在外部类型上实现外部 trait</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E7%B1%BB%E5%9E%8B"><span class="nav-number">20.3.</span> <span class="nav-text">高级类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%E7%94%A8%E6%9D%A5%E5%88%9B%E5%BB%BA%E7%B1%BB%E5%9E%8B%E5%90%8C%E4%B9%89%E8%AF%8D"><span class="nav-number">20.3.1.</span> <span class="nav-text">类型别名用来创建类型同义词</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8E%E4%B8%8D%E8%BF%94%E5%9B%9E%E7%9A%84-never-type"><span class="nav-number">20.3.2.</span> <span class="nav-text">从不返回的 never type</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%A4%A7%E5%B0%8F%E7%B1%BB%E5%9E%8B%E5%92%8C-Sized-trait"><span class="nav-number">20.3.3.</span> <span class="nav-text">动态大小类型和 Sized trait</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E5%87%BD%E6%95%B0%E4%B8%8E%E9%97%AD%E5%8C%85"><span class="nav-number">20.4.</span> <span class="nav-text">高级函数与闭包</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E9%97%AD%E5%8C%85"><span class="nav-number">20.4.1.</span> <span class="nav-text">返回闭包</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8F"><span class="nav-number">20.5.</span> <span class="nav-text">宏</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%8F%E5%92%8C%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">20.5.1.</span> <span class="nav-text">宏和函数的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-macro-rules-%E7%9A%84%E5%A3%B0%E6%98%8E%E5%AE%8F%E7%94%A8%E4%BA%8E%E9%80%9A%E7%94%A8%E5%85%83%E7%BC%96%E7%A8%8B"><span class="nav-number">20.5.2.</span> <span class="nav-text">使用 macro_rules! 的声明宏用于通用元编程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E4%BA%8E%E4%BB%8E%E5%B1%9E%E6%80%A7%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%E7%9A%84%E8%BF%87%E7%A8%8B%E5%AE%8F"><span class="nav-number">20.5.3.</span> <span class="nav-text">用于从属性生成代码的过程宏</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%B1%9E%E6%80%A7%E5%AE%8F"><span class="nav-number">20.5.4.</span> <span class="nav-text">类属性宏</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%87%BD%E6%95%B0%E5%AE%8F"><span class="nav-number">20.5.5.</span> <span class="nav-text">类函数宏</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">fea01</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fea01</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
